<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive</title>
    <link rel="stylesheet" href="http://doc.a-level.com.ua/highlightjs.css">
    <style type="text/css">svg:not(:root).svg-inline--fa {
        overflow: visible;
      }
      
      .svg-inline--fa {
        display: inline-block;
        font-size: inherit;
        height: 1em;
        overflow: visible;
        vertical-align: -0.125em;
      }
      .svg-inline--fa.fa-lg {
        vertical-align: -0.225em;
      }
      .svg-inline--fa.fa-w-1 {
        width: 0.0625em;
      }
      .svg-inline--fa.fa-w-2 {
        width: 0.125em;
      }
      .svg-inline--fa.fa-w-3 {
        width: 0.1875em;
      }
      .svg-inline--fa.fa-w-4 {
        width: 0.25em;
      }
      .svg-inline--fa.fa-w-5 {
        width: 0.3125em;
      }
      .svg-inline--fa.fa-w-6 {
        width: 0.375em;
      }
      .svg-inline--fa.fa-w-7 {
        width: 0.4375em;
      }
      .svg-inline--fa.fa-w-8 {
        width: 0.5em;
      }
      .svg-inline--fa.fa-w-9 {
        width: 0.5625em;
      }
      .svg-inline--fa.fa-w-10 {
        width: 0.625em;
      }
      .svg-inline--fa.fa-w-11 {
        width: 0.6875em;
      }
      .svg-inline--fa.fa-w-12 {
        width: 0.75em;
      }
      .svg-inline--fa.fa-w-13 {
        width: 0.8125em;
      }
      .svg-inline--fa.fa-w-14 {
        width: 0.875em;
      }
      .svg-inline--fa.fa-w-15 {
        width: 0.9375em;
      }
      .svg-inline--fa.fa-w-16 {
        width: 1em;
      }
      .svg-inline--fa.fa-w-17 {
        width: 1.0625em;
      }
      .svg-inline--fa.fa-w-18 {
        width: 1.125em;
      }
      .svg-inline--fa.fa-w-19 {
        width: 1.1875em;
      }
      .svg-inline--fa.fa-w-20 {
        width: 1.25em;
      }
      .svg-inline--fa.fa-pull-left {
        margin-right: 0.3em;
        width: auto;
      }
      .svg-inline--fa.fa-pull-right {
        margin-left: 0.3em;
        width: auto;
      }
      .svg-inline--fa.fa-border {
        height: 1.5em;
      }
      .svg-inline--fa.fa-li {
        width: 2em;
      }
      .svg-inline--fa.fa-fw {
        width: 1.25em;
      }
      
      .fa-layers svg.svg-inline--fa {
        bottom: 0;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        top: 0;
      }
      
      .fa-layers {
        display: inline-block;
        height: 1em;
        position: relative;
        text-align: center;
        vertical-align: -0.125em;
        width: 1em;
      }
      .fa-layers svg.svg-inline--fa {
        -webkit-transform-origin: center center;
                transform-origin: center center;
      }
      
      .fa-layers-counter, .fa-layers-text {
        display: inline-block;
        position: absolute;
        text-align: center;
      }
      
      .fa-layers-text {
        left: 50%;
        top: 50%;
        -webkit-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
        -webkit-transform-origin: center center;
                transform-origin: center center;
      }
      
      .fa-layers-counter {
        background-color: #ff253a;
        border-radius: 1em;
        -webkit-box-sizing: border-box;
                box-sizing: border-box;
        color: #fff;
        height: 1.5em;
        line-height: 1;
        max-width: 5em;
        min-width: 1.5em;
        overflow: hidden;
        padding: 0.25em;
        right: 0;
        text-overflow: ellipsis;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top right;
                transform-origin: top right;
      }
      
      .fa-layers-bottom-right {
        bottom: 0;
        right: 0;
        top: auto;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: bottom right;
                transform-origin: bottom right;
      }
      
      .fa-layers-bottom-left {
        bottom: 0;
        left: 0;
        right: auto;
        top: auto;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: bottom left;
                transform-origin: bottom left;
      }
      
      .fa-layers-top-right {
        right: 0;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top right;
                transform-origin: top right;
      }
      
      .fa-layers-top-left {
        left: 0;
        right: auto;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top left;
                transform-origin: top left;
      }
      
      .fa-lg {
        font-size: 1.3333333333em;
        line-height: 0.75em;
        vertical-align: -0.0667em;
      }
      
      .fa-xs {
        font-size: 0.75em;
      }
      
      .fa-sm {
        font-size: 0.875em;
      }
      
      .fa-1x {
        font-size: 1em;
      }
      
      .fa-2x {
        font-size: 2em;
      }
      
      .fa-3x {
        font-size: 3em;
      }
      
      .fa-4x {
        font-size: 4em;
      }
      
      .fa-5x {
        font-size: 5em;
      }
      
      .fa-6x {
        font-size: 6em;
      }
      
      .fa-7x {
        font-size: 7em;
      }
      
      .fa-8x {
        font-size: 8em;
      }
      
      .fa-9x {
        font-size: 9em;
      }
      
      .fa-10x {
        font-size: 10em;
      }
      
      .fa-fw {
        text-align: center;
        width: 1.25em;
      }
      
      .fa-ul {
        list-style-type: none;
        margin-left: 2.5em;
        padding-left: 0;
      }
      .fa-ul > li {
        position: relative;
      }
      
      .fa-li {
        left: -2em;
        position: absolute;
        text-align: center;
        width: 2em;
        line-height: inherit;
      }
      
      .fa-border {
        border: solid 0.08em #eee;
        border-radius: 0.1em;
        padding: 0.2em 0.25em 0.15em;
      }
      
      .fa-pull-left {
        float: left;
      }
      
      .fa-pull-right {
        float: right;
      }
      
      .fa.fa-pull-left,
      .fas.fa-pull-left,
      .far.fa-pull-left,
      .fal.fa-pull-left,
      .fab.fa-pull-left {
        margin-right: 0.3em;
      }
      .fa.fa-pull-right,
      .fas.fa-pull-right,
      .far.fa-pull-right,
      .fal.fa-pull-right,
      .fab.fa-pull-right {
        margin-left: 0.3em;
      }
      
      .fa-spin {
        -webkit-animation: fa-spin 2s infinite linear;
                animation: fa-spin 2s infinite linear;
      }
      
      .fa-pulse {
        -webkit-animation: fa-spin 1s infinite steps(8);
                animation: fa-spin 1s infinite steps(8);
      }
      
      @-webkit-keyframes fa-spin {
        0% {
          -webkit-transform: rotate(0deg);
                  transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
                  transform: rotate(360deg);
        }
      }
      
      @keyframes fa-spin {
        0% {
          -webkit-transform: rotate(0deg);
                  transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
                  transform: rotate(360deg);
        }
      }
      .fa-rotate-90 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
        -webkit-transform: rotate(90deg);
                transform: rotate(90deg);
      }
      
      .fa-rotate-180 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
        -webkit-transform: rotate(180deg);
                transform: rotate(180deg);
      }
      
      .fa-rotate-270 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
        -webkit-transform: rotate(270deg);
                transform: rotate(270deg);
      }
      
      .fa-flip-horizontal {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
        -webkit-transform: scale(-1, 1);
                transform: scale(-1, 1);
      }
      
      .fa-flip-vertical {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        -webkit-transform: scale(1, -1);
                transform: scale(1, -1);
      }
      
      .fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        -webkit-transform: scale(-1, -1);
                transform: scale(-1, -1);
      }
      
      :root .fa-rotate-90,
      :root .fa-rotate-180,
      :root .fa-rotate-270,
      :root .fa-flip-horizontal,
      :root .fa-flip-vertical,
      :root .fa-flip-both {
        -webkit-filter: none;
                filter: none;
      }
      
      .fa-stack {
        display: inline-block;
        height: 2em;
        position: relative;
        width: 2.5em;
      }
      
      .fa-stack-1x,
      .fa-stack-2x {
        bottom: 0;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        top: 0;
      }
      
      .svg-inline--fa.fa-stack-1x {
        height: 1em;
        width: 1.25em;
      }
      .svg-inline--fa.fa-stack-2x {
        height: 2em;
        width: 2.5em;
      }
      
      .fa-inverse {
        color: #fff;
      }
      
      .sr-only {
        border: 0;
        clip: rect(0, 0, 0, 0);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      
      .sr-only-focusable:active, .sr-only-focusable:focus {
        clip: auto;
        height: auto;
        margin: 0;
        overflow: visible;
        position: static;
        width: auto;
      }
      
      .svg-inline--fa .fa-primary {
        fill: var(--fa-primary-color, currentColor);
        opacity: 1;
        opacity: var(--fa-primary-opacity, 1);
      }
      
      .svg-inline--fa .fa-secondary {
        fill: var(--fa-secondary-color, currentColor);
        opacity: 0.4;
        opacity: var(--fa-secondary-opacity, 0.4);
      }
      
      .svg-inline--fa.fa-swap-opacity .fa-primary {
        opacity: 0.4;
        opacity: var(--fa-secondary-opacity, 0.4);
      }
      
      .svg-inline--fa.fa-swap-opacity .fa-secondary {
        opacity: 1;
        opacity: var(--fa-primary-opacity, 1);
      }
      
      .svg-inline--fa mask .fa-primary,
      .svg-inline--fa mask .fa-secondary {
        fill: black;
      }
      
      .fad.fa-inverse {
        color: #fff;
      }</style>
    <link href="https://fonts.googleapis.com/css?family=Anonymous+Pro&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="http://doc.a-level.com.ua/static/css/main.6aea2394.css">

    <script src="http://doc.a-level.com.ua/static/js/main.8cdf72fc.js"></script>
    
</head>
<body>
  <div class="mdViewer">
<h1 id="triangularflagonpostflexbox"><section id="triangularflagonpostflexbox_0"><img id="triangularflagonpostflexbox_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> Flex-box</section></h1>
<div><section id="triangularflagonpostflexbox_2"></section><section id="triangularflagonpostflexbox_3"><b id="triangularflagonpostflexbox_4">CSS flexbox (Flexible Box Layout Module)</b> — модуль макета гибкого контейнера — представляет собой способ компоновки элементов.</section><section id="triangularflagonpostflexbox_5">Flexbox состоит из <b id="triangularflagonpostflexbox_6">flex-контейнера (flex container)</b> — родительского контейнера и <b id="triangularflagonpostflexbox_7">гибких элементов (flex items)</b> — дочерних блоков.</section><section id="triangularflagonpostflexbox_8">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex01.png" alt="" id="triangularflagonpostflexbox_9" style="width: 600px;"></section><section id="triangularflagonpostflexbox_10">
Итак, оси flexbox — это основное понятие данной модели.</section><section id="triangularflagonpostflexbox_11"><b id="triangularflagonpostflexbox_12">Главная ось flex-контейнера (main axis)</b> — это направление, в котором располагаются его дочерние элементы. У главной оси есть начало и конец (они обозначены на схеме).</section><section id="triangularflagonpostflexbox_13"><b id="triangularflagonpostflexbox_14">Поперечная ось flex-контейнера (cross axis)</b> — это направление, перпендикулярное главной оси. У поперечной оси тоже есть начало и конец (отмечены на схеме).</section><section id="triangularflagonpostflexbox_15">Если вашей актуальной локалью является LTR (left-to-right), то направление главной оси пролегает слева направо. Направление поперечной оси пролегает сверху вниз.</section></div>
<h1 id="flexbox"><section id="flexbox_0">Основные преимущества flexbox:</section></h1>
<div><ul id="flexbox_1"><li id="flexbox_2"><section id="flexbox_3">  Блоки легко становятся гибкими, элементы могут сжиматься и растягиваться, заполняя пространство.</section></li><li id="flexbox_4"><section id="flexbox_5">  Неважно, в каком порядке расположены HTML-элементы. Вы можете изменить их порядок через CSS</section></li><li id="flexbox_6"><section id="flexbox_7">  Располагать элементы в одном из четырех направлений: слева направо, справа налево, сверху вниз или снизу вверх.</section></li><li id="flexbox_8"><section id="flexbox_9">  Переопределять порядок отображения элементов.</section></li><li id="flexbox_10"><section id="flexbox_11">  Автоматически определять размеры элементов таким образом, чтобы они вписывались в доступное пространство.</section></li><li id="flexbox_12"><section id="flexbox_13">  Решать проблему с горизонтальным и вертикальным центрированием.</section></li><li id="flexbox_14"><section id="flexbox_15">  Переносить элементы внутри контейнера, не допуская его переполнения.</section></li><li id="flexbox_16"><section id="flexbox_17">  Создавать колонки одинаковой высоты.</section></li><li id="flexbox_18"><section id="flexbox_19">  Создавать прижатый к низу страницы футер</section></li></ul></div>
<h1 id="displayflex"><section id="displayflex_0">Свойство <code id="displayflex_1">display: flex;</code></section></h1>
<div><section id="displayflex_2">
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
<span class="hljs-comment">/*генерирует flex-контейнер уровня блока*/</span>

    <span class="hljs-attribute">display</span>: -webkit-flex; 
    <span class="hljs-attribute">display</span>: flex; 
}

<span class="hljs-selector-class">.flex-container</span> {
<span class="hljs-comment">/*генерирует flex-контейнер уровня строки*/</span>

    <span class="hljs-attribute">display</span>: -webkit-inline-flex;
    <span class="hljs-attribute">display</span>: inline-flex; 
}</code></pre><section id="displayflex_4">
После установки данных значений свойства каждый дочерний элемент автоматически становится flex-элементом, выстраиваясь в ряд (вдоль главной оси) колонками одинаковой высоты, равной высоте блока-контейнера.</section><section id="displayflex_5">При этом блочные и строчные дочерние элементы ведут себя одинаково, т.е. ширина блоков равна ширине их содержимого с учетом внутренних полей и рамок элемента.</section></div>
<h1 id="flexdirection"><section id="flexdirection_0"><code id="flexdirection_1">flex-direction</code></section></h1>
<div><section id="flexdirection_2"></section><section id="flexdirection_3">Свойство <b id="flexdirection_4">flex-direction</b> определяет, каким образом flex-элементы укладываются во flex-контейнере, задавая направление главной оси flex-контейнера. Они могут располагаться в двух главных направлениях — горизонтально, как строки или вертикально, как колонки. Главная ось по умолчанию идет слева направо. Поперечная – сверху вниз.</section><section id="flexdirection_5">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-direction-row.png" alt="" id="flexdirection_6" style="width: 300px; float: left;">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-direction-col.png" alt="" id="flexdirection_7" style="width: 300px;">
</section><table><thead><tr><th><section id="flexdirection_8">property</section></th><th><section id="flexdirection_9">comment</section></th></tr></thead><tbody><tr><td><section id="flexdirection_10"><b id="flexdirection_11">row</b></section></td><td><section id="flexdirection_12">Значение по умолчанию, слева направо. Flex-элементы выкладываются в строку.</section></td></tr><tr><td><section id="flexdirection_13"><b id="flexdirection_14">row-reverse</b></section></td><td><section id="flexdirection_15">Направление справа налево. Flex-элементы выкладываются в строку относительно правого края контейнера.</section></td></tr><tr><td><section id="flexdirection_16"><b id="flexdirection_17">column</b></section></td><td><section id="flexdirection_18">Направление сверху вниз. Flex-элементы выкладываются в колонку.</section></td></tr><tr><td><section id="flexdirection_19"><b id="flexdirection_20">column-reverse</b></section></td><td><section id="flexdirection_21">Колонка с элементами в обратном порядке, снизу вверх.</section></td></tr></tbody></table><section id="flexdirection_22"></section><section id="flexdirection_23"><b id="flexdirection_24"> </b>
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: row-reverse;
}</code></pre></div>
<h1 id="flexwrap"><section id="flexwrap_0"><code id="flexwrap_1">flex-wrap</code></section></h1>
<div><section id="flexwrap_2"></section><section id="flexwrap_3">Свойство <b id="flexwrap_4">flex-wrap</b> управляет тем, как flex-контейнер будет выкладывать flex-элементы — в одну строку или в несколько, и направлением, в котором будут укладываться новые строки. По умолчанию flex-элементы укладываются в одну строку. При переполнении контейнера их содержимое будет выходить за границы flex-элементов. Не наследуется.</section><table><thead><tr><th><section id="flexwrap_5">property</section></th><th><section id="flexwrap_6">image</section></th><th><section id="flexwrap_7">comment</section></th></tr></thead><tbody><tr><td><section id="flexwrap_8"><b id="flexwrap_9">nowrap</b></section></td><td><section id="flexwrap_10"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-wnw.png" alt="" id="flexwrap_11"></section></td><td><section id="flexwrap_12">Значение по умолчанию. Flex-элементы не переносятся, а располагаются в одну линию слева направо</section></td></tr><tr><td><section id="flexwrap_13"><b id="flexwrap_14">wrap</b></section></td><td><section id="flexwrap_15"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-fww.png" alt="" id="flexwrap_16"></section></td><td><section id="flexwrap_17">Flex-элементы переносятся, располагаясь в несколько горизонтальных рядов</section></td></tr><tr><td><section id="flexwrap_18"><b id="flexwrap_19">wrap-reverse</b></section></td><td><section id="flexwrap_20"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-fwwr.png" alt="" id="flexwrap_21"></section></td><td><section id="flexwrap_22">Flex-элементы переносятся, располагаясь в обратном порядке слева-направо, при этом перенос происходит снизу вверх</section></td></tr></tbody></table><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-wrap</span>: wrap;
}</code></pre></div>
<h1 id="justifycontent"><section id="justifycontent_0"><code id="justifycontent_1">justify-content</code></section></h1>
<div><section id="justifycontent_2"></section><section id="justifycontent_3">Свойство <b id="justifycontent_4">justify-content</b> выравнивает flex-элементы по ширине flex-контейнера, распределяя оставшееся свободное пространство, незанятое flex-элементами.
</section><table><thead><tr><th><section id="justifycontent_5">property</section></th><th><section id="justifycontent_6">image</section></th><th><section id="justifycontent_7">comment</section></th></tr></thead><tbody><tr><td><section id="justifycontent_8"><b id="justifycontent_9">flex-start</b></section></td><td><section id="justifycontent_10"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-jcfs.png" alt="" id="justifycontent_11"></section></td><td><section id="justifycontent_12">Значение по умолчанию. Flex-элементы позиционируются от начала flex-контейнера.</section></td></tr><tr><td><section id="justifycontent_13"><b id="justifycontent_14">flex-end</b></section></td><td><section id="justifycontent_15"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-jcfe.png" alt="" id="justifycontent_16"></section></td><td><section id="justifycontent_17">Flex-элементы позиционируются относительно правой границы flex-контейнера.</section></td></tr><tr><td><section id="justifycontent_18"><b id="justifycontent_19">center</b></section></td><td><section id="justifycontent_20"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-jcc.png" alt="" id="justifycontent_21"></section></td><td><section id="justifycontent_22">Flex-элементы выравниваются по главной оси, свободное место между ними распределяется следующим образом: первый блок располагается в начале flex-контейнера, последний блок – в конце, все остальные блоки равномерно распределены в оставшемся пространстве, а свободное пространство равномерно распределяется между элементами.</section></td></tr><tr><td><section id="justifycontent_23"><b id="justifycontent_24">space-around</b></section></td><td><section id="justifycontent_25"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-jcsa.png" alt="" id="justifycontent_26"></section></td><td><section id="justifycontent_27">Flex-элементы выравниваются по главной оси, а свободное место делится поровну, добавляя отступы справа и слева.</section></td></tr><tr><td><section id="justifycontent_28"><b id="justifycontent_29">space-between</b></section></td><td><section id="justifycontent_30"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-jcsb.png" alt="" id="justifycontent_31"></section></td><td><section id="justifycontent_32">Элементы равномерно распределяются по всей строке, при этом первый элемент позиционируются в начале контейнера, а последний элемент позиционируется в конце контейнера.</section></td></tr></tbody></table><section id="justifycontent_33">
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: space-between;
}</code></pre></div>
<h1 id="alignitems"><section id="alignitems_0"><code id="alignitems_1">align-items</code></section></h1>
<div><section id="alignitems_2">
Свойство <b id="alignitems_3">align-items</b> выравнивает flex-элементы, в том числе и анонимные flex-элементы по перпендикулярной оси (по высоте).
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">align-items</span>: flex-start;
}</code></pre><section id="alignitems_5">
</section><table><thead><tr><th><section id="alignitems_6">property</section></th><th><section id="alignitems_7">image</section></th><th><section id="alignitems_8">comment</section></th></tr></thead><tbody><tr><td><section id="alignitems_9"><b id="alignitems_10">stretch</b></section></td><td><section id="alignitems_11"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-fias.png" alt="" id="alignitems_12"></section></td><td><section id="alignitems_13"><b id="alignitems_14"><i id="alignitems_15">Значение по умолчанию</i></b>. Flex-элементы <b id="alignitems_16"><i id="alignitems_17">растягиваются</i></b>, занимая все пространство по высоте.</section></td></tr><tr><td><section id="alignitems_18"><b id="alignitems_19">flex-start</b></section></td><td><section id="alignitems_20"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-faifs.png" alt="" id="alignitems_21"></section></td><td><section id="alignitems_22">Flex-элементы выравниваются по левому краю flex-контейнера <b id="alignitems_23"><i id="alignitems_24">относительно верхнего края блока-контейнера</i></b>.</section></td></tr><tr><td><section id="alignitems_25"><b id="alignitems_26">flex-end</b></section></td><td><section id="alignitems_27"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-faife.png" alt="" id="alignitems_28"></section></td><td><section id="alignitems_29">Flex-элементы выравниваются по левому краю flex-контейнера относительно <b id="alignitems_30"><i id="alignitems_31">нижнего края блока-контейнера.</i></b></section></td></tr><tr><td><section id="alignitems_32"><b id="alignitems_33">center</b></section></td><td><section id="alignitems_34"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-faic.png" alt="" id="alignitems_35"></section></td><td><section id="alignitems_36">Flex-элементы выравниваются <b id="alignitems_37"><i id="alignitems_38">по центру</i></b> flex-контейнера.</section></td></tr><tr><td><section id="alignitems_39"><b id="alignitems_40">baseline</b></section></td><td><section id="alignitems_41"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-fiab.png" alt="" id="alignitems_42"></section></td><td><section id="alignitems_43">Флексы выравниваются по их базовой линии.</section></td></tr></tbody></table></div>
<h1 id="aligncontent"><section id="aligncontent_0"><code id="aligncontent_1">align-content</code></section></h1>
<div><section id="aligncontent_2"></section><section id="aligncontent_3">Свойство CSS <b id="aligncontent_4">align-content</b> выравнивает линии контейнера flex в контейнере flex при наличии дополнительного пространства на перекрестной оси.</section><section id="aligncontent_5">Это свойство не имеет никакое влияние на однострочные гибкие блоки.
</section><table><thead><tr><th><section id="aligncontent_6">property</section></th><th><section id="aligncontent_7">image</section></th><th><section id="aligncontent_8">comment</section></th></tr></thead><tbody><tr><td><section id="aligncontent_9"><b id="aligncontent_10">flex-start</b></section></td><td><section id="aligncontent_11"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acfs.png" alt="" id="aligncontent_12"></section></td><td><section id="aligncontent_13">Линии упорядочиваются  начиная  с cross-start. Поперечная кромка первой линии и поперечная кромка контейнера flex сбрасываются вместе. Каждая следующая строка совпадает с предыдущей.</section></td></tr><tr><td><section id="aligncontent_14"><b id="aligncontent_15">flex-end</b></section></td><td><section id="aligncontent_16"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acfe.png" alt="" id="aligncontent_17"></section></td><td><section id="aligncontent_18">Линии  упорядочиваются начиная cross-end. Кросс-энд последней линии и кросс-энд контейнера гибкого блока сбрасываются вместе. Каждая предыдущая строка очищается следующей строкой.</section></td></tr><tr><td><section id="aligncontent_19"><b id="aligncontent_20">center</b></section></td><td><section id="aligncontent_21"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acc.png" alt="" id="aligncontent_22"></section></td><td><section id="aligncontent_23">Линии упакованы к центру контейнера Flex. Линии выравниваются по центру контейнера flex. Расстояние между кросс-стартовым краем контейнера flex и первой линией, а также между кросс-эндом контейнера flex и последней линией одинаково.</section></td></tr><tr><td><section id="aligncontent_24"><b id="aligncontent_25">space-between</b></section></td><td><section id="aligncontent_26"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acsb.png" alt="" id="aligncontent_27"></section></td><td><section id="aligncontent_28">Линии равномерно распределены в контейнере. Интервал делается так, чтобы расстояние между двумя соседними элементами было одинаковым. Поперечная кромка и поперечная кромка гибкого контейнера распределяются соответственно первой и последней кромками линии.</section></td></tr><tr><td><section id="aligncontent_29"><b id="aligncontent_30">space-around</b></section></td><td><section id="aligncontent_31"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acsa.png" alt="" id="aligncontent_32"></section></td><td><section id="aligncontent_33">Линии равномерно распределены таким образом, что пространство между двумя соседними линиями одинаковые. Пустое пространство перед первой и после последней строки равняется половине расстояния между двумя смежными линиями.</section></td></tr><tr><td><section id="aligncontent_34"><b id="aligncontent_35">stretch</b></section></td><td><section id="aligncontent_36"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acs.png" alt="" id="aligncontent_37"></section></td><td><section id="aligncontent_38">Линии растягиваются, чтобы использовать оставшееся пространство. Свободное пространство разделено поровну между всеми линиями.</section></td></tr><tr><td><section id="aligncontent_39"><b id="aligncontent_40">space-evenly</b></section></td><td><section id="aligncontent_41"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-acse.png" alt="" id="aligncontent_42"></section></td><td><section id="aligncontent_43">Сначение по умолчанию. Строки равномерно распределяются таким образом, чтобы пространство между двумя соседними строками, а также пространство перед первой строкой и после последней строки было одинаковым.</section></td></tr></tbody></table></div>
<h1 id="order"><section id="order_0"><code id="order_1">order</code></section></h1>
<div><section id="order_2"></section><section id="order_3">Свойство <b id="order_4">order</b> определяет порядок, в котором flex-элементы отображаются внутри flex-контейнера. По умолчанию для всех flex-элементов задан порядок order: 0; и они следуют друг за другом по мере добавления во flex-контейнер. Самый первый flex-элемент по умолчанию расположен слева. Чтобы поставить любой flex-элемент в начало строки, ему нужно назначить order: -1; в конец строки — order: 1.</section><section id="order_7"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-order.png" alt="" id="order_8" style="width: 400px;"></section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
}

<span class="hljs-selector-class">.flex-item</span> {
    <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;
}</code></pre></div>
<h1 id="flexgrow"><section id="flexgrow_0"><code id="flexgrow_1">flex-grow</code></section></h1>
<div><section id="flexgrow_2"></section><section id="flexgrow_3">Свойство <b id="flexgrow_4">flex-grow</b> определяет то, на сколько отдельный <code id="flexgrow_5">flex-блок</code> может быть больше соседних элементов, если это необходимо.
Он определяет, какое количество <b id="flexgrow_6"><i id="flexgrow_7">доступного пространства</i></b> внутри гибкого контейнера должно занимать элемент.</section><section id="flexgrow_8">Например, если все flex-блоки внутри flex-контейнера имеют <code id="flexgrow_9">flex-grow:1</code>, то они будут одинакового размера. Если один из них имеет <code id="flexgrow_10">flex-grow:2</code>, 
то он будет в 2 раза больше, чем все остальные.</section><section id="flexgrow_11"><b id="flexgrow_12">Применяется к: конкретному flex блоку.</b></section><section id="flexgrow_13"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-flex-grow.png" alt="" id="flexgrow_14" style="width: 400px;"></section><section id="flexgrow_15">Данное свойство входит в свойство-сокращение flex.</section><section id="flexgrow_16">Значение по умолчанию: 0.</section><section id="flexgrow_17">Стоит помнить, что <code id="flexgrow_18">flex-grow</code> работает только для главной оси (пока мы не поменяем ее направление).
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> {
	<span class="hljs-attribute">flex-grow</span>: положительное число;
}</code></pre></div>
<h1 id="flexshrink"><section id="flexshrink_0"><code id="flexshrink_1">flex-shrink</code></section></h1>
<div><section id="flexshrink_2"></section><section id="flexshrink_3"><b id="flexshrink_4"><i id="flexshrink_5">flex-shrink</i></b> — прямая противоположность <code id="flexshrink_6">flex-grow</code>. Оно определяет, насколько блоку
можно уменьшиться в размере.</section><section id="flexshrink_7"><code id="flexshrink_8">flex-shrink</code> используется, когда элементы не вмещаются в контейнер.</section><section id="flexshrink_9">Вы определяете, какие элементы должны уменьшиться в размерах, а какие — нет.</section><section id="flexshrink_10">По умолчанию <code id="flexshrink_11">flex-shrink: 1;</code> . Это значит, что блоки будут сжиматься, когда контейнер будет уменьшаться.</section><section id="flexshrink_12">Стоит помнить что <code id="flexshrink_13">flex-shrink</code> основывается на пропорциях. То есть, если у блока <code id="flexshrink_14">flex-shrink</code> равен 6, а у остальных он равен 2,
то, это значит, что наш блок будет сжиматься в три раза быстрее, чем остальные.</section><pre><code class="hljs css">Принимаются целые (1, 2, 3,…) или дробные числа (например: 0<span class="hljs-selector-class">.6</span>). Отрицательные значения игнорируются.

<span class="hljs-selector-class">.flex-item</span> {
     <span class="hljs-attribute">flex-shrink</span>: &lt;число&gt;
}
   </code></pre><section id="flexshrink_16"></section><section id="flexshrink_17">Вместе если вместе с свойством <code id="flexshrink_18">flex-shrink</code> нужно использовать <code id="flexshrink_19">flex-basis</code>,
который задает базовый размер элемента. Если ты его не укажешь, то работать твое свойство <code id="flexshrink_20">flex-shrink</code> не будет.</section><section id="flexshrink_21"><i id="flexshrink_22">Теоретический пример:</i> если у нас будет контейнер размерностью 800px, 
а элементы будут иметь <code id="flexshrink_23">flex-basis: 200px</code>, а <code id="flexshrink_24">flex-shrink</code> будет иметь стандартное число 1,
то каждый блок будет иметь свои базовые 200px, если же уменьшить контейнер до 600px, 
то элементы естественно тоже уменьшатся и будут равны по 150px. 
Если одному из элементов назначить значение <code id="flexshrink_25">flex-shrink: 0</code>,
этот элемент получит свой базовый размер 200px, 
а остальные уже равномерно распределят между собой свободное место.</section></div>
<h1 id="flexbasis"><section id="flexbasis_0"><code id="flexbasis_1">flex-basis</code></section></h1>
<div><section id="flexbasis_2"></section><section id="flexbasis_3">CSS свойство flex-basis задает базовый размер флекс элемента по основной оси. Это свойство определяет размер контент-бокса, если не задано иначе через <a href="https://developer.mozilla.org/ru/docs/Web/CSS/box-sizing" id="flexbasis_4">box-sizing</a>.
</section><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> {
  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>
}</code></pre></div>
<h1 id="flex"><section id="flex_0"><code id="flex_1">flex</code> </section></h1>
<div><section id="flex_2"></section><section id="flex_3">Flex заменяет <code id="flex_4">flex-grow</code>, <code id="flex_5">flex-shrink</code> и <code id="flex_6">flex-basis.</code></section><section id="flex_7"><b id="flex_8">Значения по умолчанию: 0 (grow) 1 (shrink) и auto (basis).</b>
</section><pre><code class="hljs css">Создадим два квадрата:

<span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#one</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">300px</span>;
}

<span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#two</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">300px</span>;
}
</code></pre><section id="flex_10"></section><section id="flex_11">У обоих квадратов одинаковый <code id="flex_12">flex-basis</code>. Это значит, что они оба будут шириной в 300px (ширина контейнера: 600px плюс <code id="flex_13">margin</code> и <code id="flex_14">padding</code>).</section><section id="flex_15">Но когда контейнер начнет увеличиваться в размерах, первый квадрат (с большим <code id="flex_16">flex-grow</code>) будет увеличиваться в два раза быстрее, 
а второй квадрат (с наибольшим <code id="flex_17">flex-shrink</code>) будет сжиматься в два раза быстрее.</section></div>
<h1 id="alignself"><section id="alignself_0"><code id="alignself_1">align-self</code></section></h1>
<div><section id="alignself_2">
Свойство <code id="alignself_3">align-self</code> выравнивает флекс-элементы текущей строки, переписывая значение <code id="alignself_4">align-items</code>.
</section><table><thead><tr><th><section id="alignself_5">property</section></th><th><section id="alignself_6">comment</section></th></tr></thead><tbody><tr><td><section id="alignself_7"><b id="alignself_8">auto</b></section></td><td><section id="alignself_9">Берёт родительское значение align-items или stretch, если нет родителя.</section></td></tr><tr><td><section id="alignself_10"><b id="alignself_11">flex-start</b></section></td><td><section id="alignself_12">Элемент выравнивается <b id="alignself_13">в начале</b> поперечной оси контейнера.</section></td></tr><tr><td><section id="alignself_14"><b id="alignself_15">flex-end</b></section></td><td><section id="alignself_16">Элемент выравнивается <b id="alignself_17">в конце</b> поперечной оси контейнера.</section></td></tr><tr><td><section id="alignself_18"><b id="alignself_19">center</b></section></td><td><section id="alignself_20">Элемент выравнивается <b id="alignself_21">по центральной линии</b> на поперечной оси.</section></td></tr><tr><td><section id="alignself_22"><b id="alignself_23">baseline</b></section></td><td><section id="alignself_24">Элемент выравнивается <b id="alignself_25">по базовой линии текста</b>.</section></td></tr><tr><td><section id="alignself_26"><b id="alignself_27">stretch</b></section></td><td><section id="alignself_28">Элемент <b id="alignself_29">растягивается</b> таким образом, чтобы занять всё свободное пространство контейнера по поперечной оси</section></td></tr></tbody></table></div>

</div>
</body>
</html>