<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive</title>
    <link rel="stylesheet" href="http://doc.a-level.com.ua/highlightjs.css">
    <style type="text/css">svg:not(:root).svg-inline--fa {
        overflow: visible;
      }
      
      .svg-inline--fa {
        display: inline-block;
        font-size: inherit;
        height: 1em;
        overflow: visible;
        vertical-align: -0.125em;
      }
      .svg-inline--fa.fa-lg {
        vertical-align: -0.225em;
      }
      .svg-inline--fa.fa-w-1 {
        width: 0.0625em;
      }
      .svg-inline--fa.fa-w-2 {
        width: 0.125em;
      }
      .svg-inline--fa.fa-w-3 {
        width: 0.1875em;
      }
      .svg-inline--fa.fa-w-4 {
        width: 0.25em;
      }
      .svg-inline--fa.fa-w-5 {
        width: 0.3125em;
      }
      .svg-inline--fa.fa-w-6 {
        width: 0.375em;
      }
      .svg-inline--fa.fa-w-7 {
        width: 0.4375em;
      }
      .svg-inline--fa.fa-w-8 {
        width: 0.5em;
      }
      .svg-inline--fa.fa-w-9 {
        width: 0.5625em;
      }
      .svg-inline--fa.fa-w-10 {
        width: 0.625em;
      }
      .svg-inline--fa.fa-w-11 {
        width: 0.6875em;
      }
      .svg-inline--fa.fa-w-12 {
        width: 0.75em;
      }
      .svg-inline--fa.fa-w-13 {
        width: 0.8125em;
      }
      .svg-inline--fa.fa-w-14 {
        width: 0.875em;
      }
      .svg-inline--fa.fa-w-15 {
        width: 0.9375em;
      }
      .svg-inline--fa.fa-w-16 {
        width: 1em;
      }
      .svg-inline--fa.fa-w-17 {
        width: 1.0625em;
      }
      .svg-inline--fa.fa-w-18 {
        width: 1.125em;
      }
      .svg-inline--fa.fa-w-19 {
        width: 1.1875em;
      }
      .svg-inline--fa.fa-w-20 {
        width: 1.25em;
      }
      .svg-inline--fa.fa-pull-left {
        margin-right: 0.3em;
        width: auto;
      }
      .svg-inline--fa.fa-pull-right {
        margin-left: 0.3em;
        width: auto;
      }
      .svg-inline--fa.fa-border {
        height: 1.5em;
      }
      .svg-inline--fa.fa-li {
        width: 2em;
      }
      .svg-inline--fa.fa-fw {
        width: 1.25em;
      }
      
      .fa-layers svg.svg-inline--fa {
        bottom: 0;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        top: 0;
      }
      
      .fa-layers {
        display: inline-block;
        height: 1em;
        position: relative;
        text-align: center;
        vertical-align: -0.125em;
        width: 1em;
      }
      .fa-layers svg.svg-inline--fa {
        -webkit-transform-origin: center center;
                transform-origin: center center;
      }
      
      .fa-layers-counter, .fa-layers-text {
        display: inline-block;
        position: absolute;
        text-align: center;
      }
      
      .fa-layers-text {
        left: 50%;
        top: 50%;
        -webkit-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
        -webkit-transform-origin: center center;
                transform-origin: center center;
      }
      
      .fa-layers-counter {
        background-color: #ff253a;
        border-radius: 1em;
        -webkit-box-sizing: border-box;
                box-sizing: border-box;
        color: #fff;
        height: 1.5em;
        line-height: 1;
        max-width: 5em;
        min-width: 1.5em;
        overflow: hidden;
        padding: 0.25em;
        right: 0;
        text-overflow: ellipsis;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top right;
                transform-origin: top right;
      }
      
      .fa-layers-bottom-right {
        bottom: 0;
        right: 0;
        top: auto;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: bottom right;
                transform-origin: bottom right;
      }
      
      .fa-layers-bottom-left {
        bottom: 0;
        left: 0;
        right: auto;
        top: auto;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: bottom left;
                transform-origin: bottom left;
      }
      
      .fa-layers-top-right {
        right: 0;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top right;
                transform-origin: top right;
      }
      
      .fa-layers-top-left {
        left: 0;
        right: auto;
        top: 0;
        -webkit-transform: scale(0.25);
                transform: scale(0.25);
        -webkit-transform-origin: top left;
                transform-origin: top left;
      }
      
      .fa-lg {
        font-size: 1.3333333333em;
        line-height: 0.75em;
        vertical-align: -0.0667em;
      }
      
      .fa-xs {
        font-size: 0.75em;
      }
      
      .fa-sm {
        font-size: 0.875em;
      }
      
      .fa-1x {
        font-size: 1em;
      }
      
      .fa-2x {
        font-size: 2em;
      }
      
      .fa-3x {
        font-size: 3em;
      }
      
      .fa-4x {
        font-size: 4em;
      }
      
      .fa-5x {
        font-size: 5em;
      }
      
      .fa-6x {
        font-size: 6em;
      }
      
      .fa-7x {
        font-size: 7em;
      }
      
      .fa-8x {
        font-size: 8em;
      }
      
      .fa-9x {
        font-size: 9em;
      }
      
      .fa-10x {
        font-size: 10em;
      }
      
      .fa-fw {
        text-align: center;
        width: 1.25em;
      }
      
      .fa-ul {
        list-style-type: none;
        margin-left: 2.5em;
        padding-left: 0;
      }
      .fa-ul > li {
        position: relative;
      }
      
      .fa-li {
        left: -2em;
        position: absolute;
        text-align: center;
        width: 2em;
        line-height: inherit;
      }
      
      .fa-border {
        border: solid 0.08em #eee;
        border-radius: 0.1em;
        padding: 0.2em 0.25em 0.15em;
      }
      
      .fa-pull-left {
        float: left;
      }
      
      .fa-pull-right {
        float: right;
      }
      
      .fa.fa-pull-left,
      .fas.fa-pull-left,
      .far.fa-pull-left,
      .fal.fa-pull-left,
      .fab.fa-pull-left {
        margin-right: 0.3em;
      }
      .fa.fa-pull-right,
      .fas.fa-pull-right,
      .far.fa-pull-right,
      .fal.fa-pull-right,
      .fab.fa-pull-right {
        margin-left: 0.3em;
      }
      
      .fa-spin {
        -webkit-animation: fa-spin 2s infinite linear;
                animation: fa-spin 2s infinite linear;
      }
      
      .fa-pulse {
        -webkit-animation: fa-spin 1s infinite steps(8);
                animation: fa-spin 1s infinite steps(8);
      }
      
      @-webkit-keyframes fa-spin {
        0% {
          -webkit-transform: rotate(0deg);
                  transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
                  transform: rotate(360deg);
        }
      }
      
      @keyframes fa-spin {
        0% {
          -webkit-transform: rotate(0deg);
                  transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
                  transform: rotate(360deg);
        }
      }
      .fa-rotate-90 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
        -webkit-transform: rotate(90deg);
                transform: rotate(90deg);
      }
      
      .fa-rotate-180 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
        -webkit-transform: rotate(180deg);
                transform: rotate(180deg);
      }
      
      .fa-rotate-270 {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
        -webkit-transform: rotate(270deg);
                transform: rotate(270deg);
      }
      
      .fa-flip-horizontal {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
        -webkit-transform: scale(-1, 1);
                transform: scale(-1, 1);
      }
      
      .fa-flip-vertical {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        -webkit-transform: scale(1, -1);
                transform: scale(1, -1);
      }
      
      .fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
        -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        -webkit-transform: scale(-1, -1);
                transform: scale(-1, -1);
      }
      
      :root .fa-rotate-90,
      :root .fa-rotate-180,
      :root .fa-rotate-270,
      :root .fa-flip-horizontal,
      :root .fa-flip-vertical,
      :root .fa-flip-both {
        -webkit-filter: none;
                filter: none;
      }
      
      .fa-stack {
        display: inline-block;
        height: 2em;
        position: relative;
        width: 2.5em;
      }
      
      .fa-stack-1x,
      .fa-stack-2x {
        bottom: 0;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        top: 0;
      }
      
      .svg-inline--fa.fa-stack-1x {
        height: 1em;
        width: 1.25em;
      }
      .svg-inline--fa.fa-stack-2x {
        height: 2em;
        width: 2.5em;
      }
      
      .fa-inverse {
        color: #fff;
      }
      
      .sr-only {
        border: 0;
        clip: rect(0, 0, 0, 0);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      
      .sr-only-focusable:active, .sr-only-focusable:focus {
        clip: auto;
        height: auto;
        margin: 0;
        overflow: visible;
        position: static;
        width: auto;
      }
      
      .svg-inline--fa .fa-primary {
        fill: var(--fa-primary-color, currentColor);
        opacity: 1;
        opacity: var(--fa-primary-opacity, 1);
      }
      
      .svg-inline--fa .fa-secondary {
        fill: var(--fa-secondary-color, currentColor);
        opacity: 0.4;
        opacity: var(--fa-secondary-opacity, 0.4);
      }
      
      .svg-inline--fa.fa-swap-opacity .fa-primary {
        opacity: 0.4;
        opacity: var(--fa-secondary-opacity, 0.4);
      }
      
      .svg-inline--fa.fa-swap-opacity .fa-secondary {
        opacity: 1;
        opacity: var(--fa-primary-opacity, 1);
      }
      
      .svg-inline--fa mask .fa-primary,
      .svg-inline--fa mask .fa-secondary {
        fill: black;
      }
      
      .fad.fa-inverse {
        color: #fff;
      }</style>
    <link href="https://fonts.googleapis.com/css?family=Anonymous+Pro&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="http://doc.a-level.com.ua/static/css/main.6aea2394.css">

    <script src="http://doc.a-level.com.ua/static/js/main.8cdf72fc.js"></script>
    
</head>
<body>
    <div class="mdViewer">
        <h1 id="triangularflagonpost1css"><section id="triangularflagonpost1css_0"><img id="triangularflagonpost1css_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 1. Что такое CSS.</section></h1>
<div><section id="triangularflagonpost1css_2"></section><section id="triangularflagonpost1css_3"><b id="triangularflagonpost1css_4">C</b>ascading <b id="triangularflagonpost1css_5">S</b>tyle <b id="triangularflagonpost1css_6">S</b>heets (<b id="triangularflagonpost1css_7">CSS</b>) — “каскадные таблицы стилей” — формальный язык описания внешнего вида документа, написанного с использованием языка разметки.       
</section><blockquote id="triangularflagonpost1css_8"><section id="triangularflagonpost1css_9"> <i id="triangularflagonpost1css_10">CSS= визуальное оформление</i></section></blockquote><section id="triangularflagonpost1css_11">
</section><blockquote id="triangularflagonpost1css_12"><section id="triangularflagonpost1css_13"> Актуальная версия: CSS 3.</section></blockquote><section id="triangularflagonpost1css_14"></section><section id="triangularflagonpost1css_15"><b id="triangularflagonpost1css_16">Каскадные таблицы стилей (CSS)</b> используются для описания внешнего вида документа, написанного языком разметки. CSS привносит <b id="triangularflagonpost1css_17">жизнь</b> в HTML-документ, выбирая шрифты, применяя цвета, определяя отступы, позиционируя элементы, анимируя взаимодействия и многое другое.</section><section id="triangularflagonpost1css_18"><b id="triangularflagonpost1css_19">Объявление стиля состоит из двух частей:</b> элемента веб-страницы — <b id="triangularflagonpost1css_20"><i id="triangularflagonpost1css_21">селектора</i></b>, и команды форматирования — <b id="triangularflagonpost1css_22"><i id="triangularflagonpost1css_23">блока объявления</i></b>.</section><section id="triangularflagonpost1css_24">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-3-css01.jpg" alt="" id="triangularflagonpost1css_25" style="width: 500px; margin: 0px auto; display: block;"></section><section id="triangularflagonpost1css_26">
Вы можете прочитать это так:  </section><pre><code class="hljs 1c">КТО { ЧТО: КАК; }


<span class="hljs-keyword">или</span>


СЕЛЕКТОР {СВОЙСТВО: ЗНАЧЕНИЕ}</code></pre><section id="triangularflagonpost1css_28"></section><section id="triangularflagonpost1css_29">Такой блок называется <b id="triangularflagonpost1css_30">«CSS-правило»</b>. Каждое CSS-правило содержит хотя бы один селектор и свойство.</section><section id="triangularflagonpost1css_31">CSS представляет собой процесс из трех частей:
</section><ul id="triangularflagonpost1css_32"><li id="triangularflagonpost1css_33"><section id="triangularflagonpost1css_34">  <b id="triangularflagonpost1css_35">селектор</b> определяет, на какой элемент или элементы нацелиться;</section></li><li id="triangularflagonpost1css_36"><section id="triangularflagonpost1css_37">  <b id="triangularflagonpost1css_38">свойство</b> определяет характеристики для изменения;</section></li><li id="triangularflagonpost1css_39"><section id="triangularflagonpost1css_40">  <b id="triangularflagonpost1css_41">значение</b> определяет, как изменить эту характеристику.</section></li></ul><section id="triangularflagonpost1css_42">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-3-css02.jpg" alt="" id="triangularflagonpost1css_43" style="width: 500px;"></section><section id="triangularflagonpost1css_44">
    ❗ значение отделяется от имени двоеточием;</section><section id="triangularflagonpost1css_45">    ❗ каждая пара "свойство: значение" заканчивается точкой с запятой;</section><section id="triangularflagonpost1css_46">Вообще, CSS довольно элементарный формальный язык, который придумали для описания внешнего вида документов. Это говорит о том, что он довольно прост и состоит из самобытных примитивных конструкций, которые не так сложны для изучения. Самое сложное не синтаксис, не правила написания конструкций, а огромное количество CSS свойств для запоминания, которые выполняют различные задачи. </section><section id="triangularflagonpost1css_47">👉Пример:</section><pre><code class="hljs http"><span class="hljs-attribute">HTML</span>:   &lt;h1&gt;Title&lt;/h1&gt;

<span class="css"><span class="hljs-selector-tag">CSS</span>:    <span class="hljs-selector-tag">h1</span> {
            <span class="hljs-attribute">color</span>: red;
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
        }</span></code></pre><section id="triangularflagonpost1css_49">
Здесь для элемента <i id="triangularflagonpost1css_50">h1</i> установлен красный цвет (<i id="triangularflagonpost1css_51">color: red</i>) и размер шрифта ( <i id="triangularflagonpost1css_52">font-size: 18px</i> )</section></div>
<h1 id="triangularflagonpost2"><section id="triangularflagonpost2_0"><img id="triangularflagonpost2_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 2. Способы задания стилей</section></h1>
<div><h2 id="_21"><section id="_21_0">2.1. Внешняя таблица стилей</section></h2><div><section id="_21_1">
Включает в себя подключение стилей через текстовый файл с расширением .css.</section><section id="_21_2">Она подключается к веб-странице с помощью тега <code id="_21_3">&lt;link&gt;</code>. Лучше подключать стили внутри<code id="_21_4"> &lt;head&gt;</code>, но это необязательно. Тег <code id="_21_5">&lt;link&gt;</code> будет работать и в другом месте страницы.</section><section id="_21_6">К каждой веб-странице можно присоединить несколько таблиц стилей, добавляя последовательно несколько тегов <code id="_21_7">&lt;link&gt;</code>, указав в атрибуте тега <code id="_21_8">media</code> назначение данной таблицы стилей (<a href="https://msiter.ru/references/html-reference/link/media" id="_21_9">https://msiter.ru/references/html-reference/link/media</a>). <code id="_21_10">rel="stylesheet"</code> указывает тип ссылки (ссылка на таблицу стилей).</section><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"all"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/main.css"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"all"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/assets.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><section id="_21_12"></section><section id="_21_13"><b id="_21_14"><img id="_21_15" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/heavy_plus_sign.png" height="20"> Преимущества внешних CSS:</b></section><ul id="_21_16"><li id="_21_17"><section id="_21_18">  Меньший размер страницы HTML и более чистая структура файла.</section></li><li id="_21_19"><section id="_21_20">  Быстрая скорость загрузки.</section></li><li id="_21_21"><section id="_21_22">  Для разных страниц может быть использован один и тот же <b id="_21_23">.css</b> файл.</section></li></ul><section id="_21_24">
<b id="_21_25"><img id="_21_26" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/heavy_minus_sign.png" height="20"> Недостатки внешних CSS:</b></section><ul id="_21_27"><li id="_21_28"><section id="_21_29">  Страница может некорректно отображаться до полной загрузки внешнего CSS.</section></li></ul></div><h2 id="_22"><section id="_22_0">2.2. Внутренние стили</section></h2><div><section id="_22_1">
<b id="_22_2">Внутренние стили</b> встраиваются в раздел <code id="_22_3">&lt;head&gt;&lt;/head&gt;</code> HTML-документа и определяются внутри тега <code id="_22_4">&lt;style&gt;&lt;/style&gt;</code>. Внутренние стили имеют приоритет над внешними, но уступают встроенным стилям (заданным через атрибут style).</section><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">h2</span> {
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28px</span>;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">32px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><section id="_22_6">
При таком варианте подключения классы и идентификаторы (ID) могут быть использованы для обращения к CSS коду, однако, они будут активны только на этой конкретной странице. CSS стили подключенные таким путем загружаются при каждой повторной загрузке страницы, поэтому они могут повлиять на скорость ее загрузки.</section></div><h2 id="_23"><section id="_23_0">2.3. Встроенные (инлайновые) стили</section></h2><div><section id="_23_1">
Инлайновые стили - это когда CSS-код в HTML-файле непосредственно внутри тега элемента с помощью атрибута style:</section><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 32px;"</span>&gt;</span>Heading 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre><hr id="_23_3"><section id="_23_4">
---</section></div></div>
<h1 id="triangularflagonpost3css"><section id="triangularflagonpost3css_0"><img id="triangularflagonpost3css_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 3. Селекторы CSS</section></h1>
<div><section id="triangularflagonpost3css_2"></section><section id="triangularflagonpost3css_3">Так же, как в HTML есть <i id="triangularflagonpost3css_4">теги</i>, в CSS есть "<i id="triangularflagonpost3css_5">селекторы</i>".</section><section id="triangularflagonpost3css_6"><b id="triangularflagonpost3css_7">Селекторы </b>– это имена стилей, которым вы будете прописывать свойства.</section><section id="triangularflagonpost3css_8"><b id="triangularflagonpost3css_9">Свойства </b>– это ключевые слова, такие как <a href="https://msiter.ru/references/css-reference/color" id="triangularflagonpost3css_10">color</a>, <a href="https://msiter.ru/references/css-reference/font-weight" id="triangularflagonpost3css_11">font-weight</a> или <a href="https://msiter.ru/references/css-reference/background-color" id="triangularflagonpost3css_12">background-color</a>, которым присвоены определенные значения.  Значения свойств присваиваются при помощи двоеточия и разделяются точкой с запятой:</section><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {
   <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;
   <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;
}</code></pre><section id="triangularflagonpost3css_14"></section><section id="triangularflagonpost3css_15">Селекторы бывают:</section><ul id="triangularflagonpost3css_16"><li id="triangularflagonpost3css_17"><section id="triangularflagonpost3css_18">  универсальными</section></li><li id="triangularflagonpost3css_19"><section id="triangularflagonpost3css_20">  теговый селектор  (селектором элемента)</section></li><li id="triangularflagonpost3css_21"><section id="triangularflagonpost3css_22">  классовый селектор</section></li><li id="triangularflagonpost3css_23"><section id="triangularflagonpost3css_24">  селектор идентификатора</section></li><li id="triangularflagonpost3css_25"><section id="triangularflagonpost3css_26">  селектор потомка</section></li><li id="triangularflagonpost3css_27"><section id="triangularflagonpost3css_28">  дочерний селектор</section></li><li id="triangularflagonpost3css_29"><section id="triangularflagonpost3css_30">  соседний селектор</section></li><li id="triangularflagonpost3css_31"><section id="triangularflagonpost3css_32">  родственный селектор</section></li><li id="triangularflagonpost3css_33"><section id="triangularflagonpost3css_34">  селектор атрибута</section></li><li id="triangularflagonpost3css_35"><section id="triangularflagonpost3css_36">  селектор псевдокласса</section></li><li id="triangularflagonpost3css_37"><section id="triangularflagonpost3css_38">  селектор псевдоэлементов</section></li></ul><h2 id="_31"><section id="_31_0">3.1. Универсальный  селектор (*) </section></h2><div><section id="_31_1">
<b id="_31_2">Универсальный  селектор</b> - соответствует <b id="_31_3"><i id="_31_4">любому HTML-элементу</i></b>. 
</section><blockquote id="_31_5"><section id="_31_6"> <b id="_31_7">Синтаксис:   * {...}</b> </section></blockquote><section id="_31_8">
</section><pre><code class="hljs css">* {<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;}      <span class="hljs-selector-tag">-</span>  обнулит внешние отступы для всех элементов сайта. </code></pre><section id="_31_10">
Также селектор может использоваться в комбинации с псевдоклассом или псевдоэлементом: <code id="_31_12">*:after {CSS-стили}</code>, <code id="_31_13">*:checked {CSS-стили}</code>.</section></div><h2 id="_32"><section id="_32_0">3.2. Теговый електор элемента</section></h2><div><section id="_32_1">
<b id="_32_2">Теговый селектор</b> позволяет задавать стили <b id="_32_3"><i id="_32_4">для всех элементов</i></b> данного типа (тега). 
</section><blockquote id="_32_5"><section id="_32_6"> <b id="_32_7">Синтаксис:   a {...}</b></section></blockquote><section id="_32_8"></section><section id="_32_9">Допустим, вам нужно изменить шрифт и цвет <b id="_32_10"><i id="_32_11">всех тегов</i></b> <code id="_32_12">&lt;ul&gt;</code>, которые имеются на веб-странице:</section><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> {
    <span class="hljs-attribute">background-color</span>: black;
}</code></pre></div><h2 id="_33class"><section id="_33class_0">3.3. Селектор класса (class)</section></h2><div><section id="_33class_1">
<b id="_33class_2">Селектор класса</b> - позволяет задавать стили для одного и более элементов с одинаковым именем класса, размещенных в разных местах страницы. !!! Вы можете использовать любое имя для вашего класса, но оно не должно начинаться с цифры.
</section><blockquote id="_33class_3"><section id="_33class_4"> <b id="_33class_5">Синтаксис:   .a {...}</b></section></blockquote><pre><code class="hljs http"><span class="hljs-attribute">HTML</span>:   

<span class="jboss-cli">    &lt;div class=<span class="hljs-string">"main-nav"</span>&gt;<span class="hljs-string">...</span>&lt;<span class="hljs-string">/div</span>&gt;
    &lt;h1 class=<span class="hljs-string">"main-nav"</span>&gt;<span class="hljs-string">...</span>&lt;<span class="hljs-string">/h1</span>&gt;
    		  
		  
CSS:

    <span class="hljs-string">.main-nav</span> {
        background-color: black;
    }</span></code></pre><h3 id="h3-10"><section id="h3-10_0">Правила написания классов</section></h3><div><ul id="h3-10_1"><li id="h3-10_2"><section id="h3-10_3">  в CSS перед названием селектора класса обязательно ставится точка (но при присвоении класса в HTML-документе эта точка не нужна);</section></li><li id="h3-10_4"><section id="h3-10_5">  в названии классов можно использовать только буквы <i id="h3-10_6">латинского алфавита, дефис, символ подчеркивания, цифры</i>;</section></li><li id="h3-10_7"><section id="h3-10_8">  название класса всегда должно начинаться с буквы (правильные варианты названий: <b id="h3-10_10">.intro</b>, <b id="h3-10_11">.img-border</b>, <b id="h3-10_12">.nav<i id="h3-10_13">menu</i>01</b>; неправильные: <b id="h3-10_14">.2color</b>, <b id="h3-10_15">.-link</b>, <b id="h3-10_16">._divider</b>;</section></li><li id="h3-10_17"><section id="h3-10_18">  названия классов CSS чувствительны к регистру, поэтому классы вроде <b id="h3-10_19">.review</b> и <b id="h3-10_20">.Review</b> будут восприниматься как два отдельных.</section></li></ul></div></div><h2 id="_34id"><section id="_34id_0">3.4.  Селектор идентификатора (id)</section></h2><div><section id="_34id_1">
<b id="_34id_2">Селектор идентификатора</b>- позволяет задавать стили для конкретного элемента (id должен быть уникальным!). Записывается он почти так же, как и класс, только в CSS вместо точки ставится символ решетки <b id="_34id_3">#: </b>
</section><blockquote id="_34id_4"><section id="_34id_5"> <b id="_34id_6">Синтаксис:  #a {...}</b></section></blockquote><pre><code class="hljs applescript">HTML:  
    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"nav"</span>&gt;...&lt;/<span class="hljs-keyword">div</span>&gt;

CSS:    
    <span class="hljs-comment">#nav {</span>
        background-color: black;
    }</code></pre><section id="_34id_8"></section><section id="_34id_9">Давайте рассмотрим разницу между идентификатором и классом. Существует несколько отличий:</section><ul id="_34id_10"><li id="_34id_11"><section id="_34id_12">  ID – это уникальное название элемента на веб-странице, которое должно встречаться на ней <i id="_34id_13">только один раз</i> (например, шапка сайта и подвал: <b id="_34id_14">id="header"</b> и <b id="_34id_15">id="footer"</b>), в то время как класс может присваиваться нескольким элементам с целью отличать их от остальных;</section></li><li id="_34id_16"><section id="_34id_17">  идентификаторы удобны для JavaScript-разработчиков, поскольку позволяют получить быстрый доступ к элементу DOM из скриптов (во многом именно поэтому необходимо, чтобы ID встречался на странице лишь один раз);</section></li><li id="_34id_18"><section id="_34id_19">  каждое правило CSS имеет свой так называемый вес (от веса зависит, какое из правил получит более высокий приоритет при выполнении). Идентификатор имеет больший вес, чем класс, поэтому, если элементу присвоен и ID, и класс, предпочтение отдается ID. 
</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>
    <span class="hljs-params">&lt;p id="text" class="content"&gt;</span>текст<span class="hljs-params">&lt;/p&gt;</span> \
<span class="hljs-symbol">	
CSS:</span>
    <span class="hljs-meta">#text {</span>
<span class="hljs-symbol">    	color:</span> yellow;
    }
    
    .<span class="hljs-class">content </span>{
<span class="hljs-symbol">    	color:</span> blue;
    }

** У ID бOльший вес, поэтому цвет текста будет желтым (yellow).</code></pre><section id="_34id_21">
</section></li><li id="_34id_22"><section id="_34id_23">  с помощью идентификаторов можно ставить якорные ссылки на определенные элементы веб-страницы. Достаточно присвоить этому элементу ID</section></li></ul></div><h2 id="_35"><section id="_35_0">3.5. Селекторы групп</section></h2><div><section id="_35_1">
<b id="_35_2">Селекторы групп</b> позволяют задавать стили сразу нескольким элементам.
</section><blockquote id="_35_3"><section id="_35_4"> <b id="_35_5">Синтаксис:   a, b, c  { … }</b></section></blockquote><section id="_35_6"></section><section id="_35_7">Например, необходимо сделать шрифт жирным для нескольких элементов веб-страницы – <code id="_35_8">&lt;p&gt;</code> и  <code id="_35_9">&lt;h1&gt;</code>. Можно было бы записать этот стиль отдельно для каждого элемента: 
	</section><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">font-weight</span>: bold;
}

<span class="hljs-selector-tag">h1</span> {
	<span class="hljs-attribute">font-weight</span>: bold;
}


Можно записать так:

<span class="hljs-selector-tag">p</span>, <span class="hljs-selector-tag">h1</span> {
	<span class="hljs-attribute">font-weight</span>: bold;
}</code></pre></div><h2 id="_36"><section id="_36_0">3.6. Селектор потомка</section></h2><div><section id="_36_1">
<b id="_36_2">Селектор потомка</b> - позволяет задавать стили к элементам, расположенным внутри элемента-контейнера;
</section><blockquote id="_36_3"><section id="_36_4"> <b id="_36_5">Синтаксис:   a  b { ... }</b></section></blockquote><section id="_36_6">
</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>   
    <span class="hljs-params">&lt;div class="main-nav"&gt;</span>
        <span class="hljs-params">&lt;a href="#"&gt;</span>Link<span class="hljs-params">&lt;/a&gt;</span>
    <span class="hljs-params">&lt;/div&gt;</span>  
<span class="hljs-symbol">
CSS:</span> 	
    .main-nav <span class="hljs-class">a </span>{
	    background-color: black;
	}</code></pre></div><h2 id="_37"><section id="_37_0">3.7. Дочерний селектор</section></h2><div><section id="_37_1">
<b id="_37_2">Дочерний селектор</b> - позволяет задавать стили к элементам, которые являются прямыми потомкам (т.е. идут сразу за родительским элементом и между ними нет других элементов);
</section><blockquote id="_37_3"><section id="_37_4"> <b id="_37_5">Синтаксис:</b>  <b id="_37_6">a &gt; b { … }</b></section></blockquote><section id="_37_7">
</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>   
    <span class="hljs-params">&lt;div class="wrap"&gt;</span>
        <span class="hljs-params">&lt;p&gt;</span>text with font-size <span class="hljs-number">28</span>px<span class="hljs-params">&lt;/p&gt;</span>
        <span class="hljs-params">&lt;div&gt;</span>
        	<span class="hljs-params">&lt;p&gt;</span>text<span class="hljs-params">&lt;/p&gt;</span>
        <span class="hljs-params">&lt;/div&gt;</span>
    <span class="hljs-params">&lt;/div&gt;</span>
<span class="hljs-symbol">
CSS:</span>	
    .wrap &gt; <span class="hljs-class">p </span>{
	    font-size: <span class="hljs-number">28</span>px;
	}</code></pre></div><h2 id="_38c"><section id="_38c_0">3.8. Cоседние селекторы </section></h2><div><section id="_38c_1">
<b id="_38c_2">Cоседние селекторы</b> - выбирает элемент, который находится непосредственно после указанного элемента, если у них общий родитель.
</section><blockquote id="_38c_3"><section id="_38c_4"> <b id="_38c_5">Синтаксис: a + b { … }</b></section></blockquote><section id="_38c_6">
</section><pre><code class="hljs angelscript">HTML: 
    &lt;div <span class="hljs-keyword">class</span>="<span class="hljs-symbol">box</span>"&gt;
        &lt;<span class="hljs-symbol">h1</span>&gt;<span class="hljs-symbol">Title</span> <span class="hljs-symbol">H1</span>&lt;/<span class="hljs-symbol">h1</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">p</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">p</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">p</span>&gt;
    &lt;/<span class="hljs-symbol">div</span>&gt;

<span class="hljs-symbol">CSS:
<span class="hljs-symbol">h1</span></span> + <span class="hljs-symbol">p</span> {
    background: #f00;
}</code></pre><section id="_38c_8"></section><section id="_38c_9">Cелектор <code id="_38c_10">h1 + p </code>выберет тот <code id="_38c_11">&lt;p&gt;</code> элемент, который  находится непосредственно после элемента <code id="_38c_12">&lt;h1&gt;</code>.</section></div><h2 id="_39"><section id="_39_0">3.9. Родственные селекторы</section></h2><div><section id="_39_1">
<b id="_39_2">Родственные селекторы </b>- выбирает все элементы, которые находятся <b id="_39_3"><i id="_39_4">после указанного элемента, если у них общий родитель</i></b>.</section><blockquote id="_39_5"><section id="_39_6"> <b id="_39_7">Синтаксис:  a ~ b { … }</b></section></blockquote><section id="_39_8">
</section><pre><code class="hljs angelscript">HTML:
    &lt;div <span class="hljs-keyword">class</span>="<span class="hljs-symbol">box</span>"&gt;
        &lt;<span class="hljs-symbol">span</span>&gt;к этому элементу стили не пременятся!&lt;/<span class="hljs-symbol">span</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">p</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">p</span>&gt;
        &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">some</span> <span class="hljs-symbol">text</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">p</span>&gt;
        &lt;<span class="hljs-symbol">span</span>&gt;у этого элемента будет красный фон!&lt;/<span class="hljs-symbol">span</span>&gt;
        &lt;<span class="hljs-symbol">span</span>&gt;у этого элемента будет красный фон!&lt;/<span class="hljs-symbol">span</span>&gt;
    &lt;/<span class="hljs-symbol">div</span>&gt;

<span class="hljs-symbol">CSS:
    <span class="hljs-symbol">p</span></span> ~ <span class="hljs-symbol">span</span> {
      background: #f00;
    }</code></pre><section id="_39_10"></section><section id="_39_11">Селектор  <b id="_39_12">p ~ span</b>  выберет все элементы <code id="_39_13">&lt;span&gt;</code>, которые находятся после элемента <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/p" id="_39_14">&lt;p&gt;</a> внутри одного родителя.</section></div><h2 id="_310c"><section id="_310c_0">3.10. Cелектор атрибута </section></h2><div><section id="_310c_1">
<b id="_310c_2">Cелектор атрибута </b> - позволяет задавать стили к элементам на основе имени атрибута или значения атрибута;</section><blockquote id="_310c_3"><section id="_310c_4"> <b id="_310c_5">Синтаксис: a[attr=”value”] { … }</b></section></blockquote><section id="_310c_6">
</section><pre><code class="hljs fsharp">HTML:   
    &lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"text"</span>&gt;
    &lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"password"</span>&gt;

CSS:   
    input[<span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"text"</span>] {
        font-size: <span class="hljs-number">28</span>px;
    }</code></pre><section id="_310c_8"></section><section id="_310c_9">❗  Селекторы можно объединять, группировать, чтобы добиться желаемого результата</section><section id="_310c_10">
Селекторы атрибутов выбирают элементы на основе имени атрибута или <b id="_310c_11">значения атрибута:</b>
</section><table><thead><tr><th><section id="_310c_12">атрибут</section></th><th><section id="_310c_13">когда применять</section></th></tr></thead><tbody><tr><td><section id="_310c_14">атрибут</section></td><td><section id="_310c_15">все элементы, содержащие указанный атрибут, [alt] — все элементы, для которых задан атрибут alt</section></td></tr><tr><td><section id="_310c_16">селектор[атрибут]</section></td><td><section id="_310c_17">элементы данного типа,<b id="_310c_18">содержащие указанный атрибут</b>, <code id="_310c_19">img[alt]</code> — только картинки, для которых задан атрибут <code id="_310c_20">alt</code></section></td></tr><tr><td><section id="_310c_21">селектор[атрибут='значение']</section></td><td><section id="_310c_22">элементы данного типа, <b id="_310c_23">содержащие указанный атрибут с конкретным значением</b>, <code id="_310c_24">img[title='flower']</code> — все картинки, название которых содержит слово flower</section></td></tr><tr><td><section id="_310c_25">селектор[атрибут~='значение']</section></td><td><section id="_310c_26">элементы <b id="_310c_27">частично содержащие данное значение</b>, например, если для элемента задано несколько классов через пробел, <code id="_310c_28">p[class~='feature']</code> — абзацы, имя класса которых содержит feature</section></td></tr><tr><td><section id="_310c_29">селектор[атрибут|='значение']</section></td><td><section id="_310c_30">элементы, список значений атрибута которых <b id="_310c_31">начинается с указанного слова</b>, <code id="_310c_32">p[class|='feature']</code> — абзацы, имя класса которых feature или начинается на feature</section></td></tr><tr><td><section id="_310c_33">селектор[атрибут^='значение']</section></td><td><section id="_310c_34">элементы, значение атрибута которых начинается с указанного значения, <code id="_310c_35">a[href^='http://']</code> — все ссылки, начинающиеся на <code id="_310c_36">http://</code></section></td></tr><tr><td><section id="_310c_37">селектор[атрибут$='значение']</section></td><td><section id="_310c_38">элементы, значение атрибута которых <b id="_310c_39">заканчивается указанным значением</b>, <code id="_310c_40">img[src$='.png']</code> — все картинки в формате <code id="_310c_41">png</code></section></td></tr><tr><td><section id="_310c_42">селектор[атрибут*='значение']</section></td><td><section id="_310c_43">элементы, значение атрибута которых содержит в <b id="_310c_44">любом месте</b> указанное слово, <code id="_310c_45">a[href*='book']</code> — все ссылки, название которых содержит <code id="_310c_46">book</code>.</section></td></tr></tbody></table><hr id="_310c_47"><section id="_310c_48"></section><section id="_310c_49"><b id="_310c_50">Селекторы можно комбинировать, записывая последовательно, без пробела:</b></section><ul id="_310c_51"><li id="_310c_52"><section id="_310c_53">  .c1.c2 – элементы одновременно с двумя классами c1 и c2</section></li><li id="_310c_54"><section id="_310c_55">  a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited</section><section id="_310c_56"><img id="_310c_57" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/bulb.png" height="20"> Почитать еще можно <a href="https://learn.javascript.ru/css-selectors#osnovnye-vidy-selektorov" id="_310c_58">тут</a></section></li></ul></div></div>
<h1 id="triangularflagonpost4"><section id="triangularflagonpost4_0"><img id="triangularflagonpost4_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 4. Каскад (”вес” селекторов)</section></h1>
<div><section id="triangularflagonpost4_2"></section><section id="triangularflagonpost4_3"><b id="triangularflagonpost4_4">Каскадность CSS </b>– это механизм, благодаря которому к элементу HTML-документа может применяться более чем одно правило CSS. Правила могут исходить из различных источников: из внешней и внутренней таблицы стилей, от механизма наследования, от родительских элементов, от классов и ID, от селектора тега, от атрибута <b id="triangularflagonpost4_5">style</b> и т. д. </section><section id="triangularflagonpost4_6">Поскольку в этих случаях часто происходит конфликт стилей, была создана система приоритетов: в конечном итоге применяется тот стиль, который исходит от источника с более высоким приоритетом.</section><section id="triangularflagonpost4_7"><b id="triangularflagonpost4_8"> <img id="triangularflagonpost4_9" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/arrow_right.png" height="20"> 1) специфичность (”вес” селектора):_</b>
</section><table><thead><tr><th><section id="triangularflagonpost4_10">Селектор</section></th><th><section id="triangularflagonpost4_11"> Вес селектора</section></th></tr></thead><tbody><tr><td><section id="triangularflagonpost4_12">Селектор тега (tag name):</section></td><td><section id="triangularflagonpost4_13"> 1</section></td></tr><tr><td><section id="triangularflagonpost4_14">Селектор класса (class):</section></td><td><section id="triangularflagonpost4_15"> 10</section></td></tr><tr><td><section id="triangularflagonpost4_16">Селектор ID:</section></td><td><section id="triangularflagonpost4_17"> 100</section></td></tr><tr><td><section id="triangularflagonpost4_18">Inline-стиль:</section></td><td><section id="triangularflagonpost4_19"> 1000</section></td></tr></tbody></table><section id="triangularflagonpost4_20"></section><section id="triangularflagonpost4_21">.</section><section id="triangularflagonpost4_22">Когда селектор состоит из нескольких других селекторов, необходимо посчитать их общий вес. Вот как вычисляется приоритет: за каждый селектор добавляется 1 в соответствующую ячейку. В остальных ячейках стоят нули. Чтобы получить общий вес, необходимо «склеить» все числа в ячейках.</section><table><thead><tr><th><section id="triangularflagonpost4_23">Селектор</section></th><th><section id="triangularflagonpost4_24"> ID</section></th><th><section id="triangularflagonpost4_25"> Класс</section></th><th><section id="triangularflagonpost4_26"> Тег </section></th><th><section id="triangularflagonpost4_27">Общий вес</section></th></tr></thead><tbody><tr><td><section id="triangularflagonpost4_28">p</section></td><td><section id="triangularflagonpost4_29"> 0</section></td><td><section id="triangularflagonpost4_30"> 0</section></td><td><section id="triangularflagonpost4_31"> 1</section></td><td><section id="triangularflagonpost4_32"> 1</section></td></tr><tr><td><section id="triangularflagonpost4_33">.class</section></td><td><section id="triangularflagonpost4_34"> 0</section></td><td><section id="triangularflagonpost4_35"> 1</section></td><td><section id="triangularflagonpost4_36"> 0</section></td><td><section id="triangularflagonpost4_37"> 10</section></td></tr><tr><td><section id="triangularflagonpost4_38">p.class</section></td><td><section id="triangularflagonpost4_39"> 0</section></td><td><section id="triangularflagonpost4_40"> 1</section></td><td><section id="triangularflagonpost4_41"> 1</section></td><td><section id="triangularflagonpost4_42"> 11</section></td></tr><tr><td><section id="triangularflagonpost4_43">#id</section></td><td><section id="triangularflagonpost4_44"> 1</section></td><td><section id="triangularflagonpost4_45"> 0</section></td><td><section id="triangularflagonpost4_46"> 0</section></td><td><section id="triangularflagonpost4_47"> 100</section></td></tr><tr><td><section id="triangularflagonpost4_48">#id p</section></td><td><section id="triangularflagonpost4_49"> 1</section></td><td><section id="triangularflagonpost4_50"> 0</section></td><td><section id="triangularflagonpost4_51"> 1</section></td><td><section id="triangularflagonpost4_52"> 101</section></td></tr><tr><td><section id="triangularflagonpost4_53">#id .class</section></td><td><section id="triangularflagonpost4_54"> 1</section></td><td><section id="triangularflagonpost4_55"> 1</section></td><td><section id="triangularflagonpost4_56"> 0</section></td><td><section id="triangularflagonpost4_57"> 110</section></td></tr><tr><td><section id="triangularflagonpost4_58">p a</section></td><td><section id="triangularflagonpost4_59"> 0</section></td><td><section id="triangularflagonpost4_60"> 0</section></td><td><section id="triangularflagonpost4_61"> 2</section></td><td><section id="triangularflagonpost4_62"> 2</section></td></tr></tbody></table><section id="triangularflagonpost4_63">
<b id="triangularflagonpost4_64"> <img id="triangularflagonpost4_65" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/arrow_right.png" height="20"> <i id="triangularflagonpost4_66">2) порядок - </i></b>чем ниже находится селектор по коду, тем его вес выше</section><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>; } 

<span class="hljs-selector-tag">p</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">22px</span>; }</code></pre><section id="triangularflagonpost4_68"></section><section id="triangularflagonpost4_69">Если случилось так, что два селектора имеют одинаковый вес, то приоритет отдается тому стилю, который находится ниже в коде. Если для одного элемента задан стиль и во внешней, и во внутренней таблицах, то приоритет отдается стилю в той таблице, которая находится ниже в коде. </section><section id="triangularflagonpost4_70"><b id="triangularflagonpost4_71">Пример:</b> во внутренней таблице стилей задан красный цвет для тегов <code id="triangularflagonpost4_72">&lt;p&gt;*</code>, а во внешней – зеленый цвет для этих же тегов. В HTML-документе вы первым делом подключили внешнюю таблицу стилей, а затем добавили внутреннюю таблицу с помощью тега <b id="triangularflagonpost4_73"><code id="triangularflagonpost4_74">&lt;style&gt;...&lt;/style&gt;</code></b>. В итоге цвет тегов <code id="triangularflagonpost4_75">&lt;p&gt;</code> будет красным.</section><section id="triangularflagonpost4_76">Это – один из способов управлять значимостью стилей. Еще один способ повысить приоритет – специально увеличить вес селектора, например, добавив к нему ID или класс.</section><section id="triangularflagonpost4_77"><b id="triangularflagonpost4_78"> <img id="triangularflagonpost4_79" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/arrow_right.png" height="20"> <i id="triangularflagonpost4_80">3) правило !important</i></b> (самый сильный приоритет):</section><section id="triangularflagonpost4_81">Если вы столкнулись с экстренным случаем и вам необходимо повысить значимость какого-либо свойства, можно добавить к нему объявление <b id="triangularflagonpost4_82">!important</b>:</section><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span> <span class="hljs-meta">!important</span>; }

<span class="hljs-selector-tag">h3</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; }</code></pre><section id="triangularflagonpost4_84"></section><section id="triangularflagonpost4_85">Также <code id="triangularflagonpost4_86">!important</code> перекрывает inline-стили. Слишком частое применение <code id="triangularflagonpost4_87">!important</code> не приветствуется многими разработчиками. В основном, данное объявление принято использовать лишь тогда, когда конфликт стилей нельзя победить иными способами.</section></div>
<h1 id="triangularflagonpost5"><section id="triangularflagonpost5_0"><img id="triangularflagonpost5_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20">  5. Комбинирование и группировка селекторов</section></h1>
<div><section id="triangularflagonpost5_2"></section><section id="triangularflagonpost5_3">Для более точного отбора элементов для форматирования можно использовать комбинации селекторов:
</section><pre><code class="hljs markdown">a[<span class="hljs-string">href</span>][<span class="hljs-symbol">title</span>] { color: red; }</code></pre><section id="triangularflagonpost5_5"></section><section id="triangularflagonpost5_6">Один и тот же стиль можно одновременно применить к нескольким элементам. Для этого необходимо в левой части объявления перечислить через запятую нужные селекторы:</section><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,
<span class="hljs-selector-tag">span</span> { <span class="hljs-attribute">color</span>: black; }</code></pre><h2 id="h2-20"><section id="h2-20_0">Иерархия селекторов</section></h2><div><section id="h2-20_1"></section><section id="h2-20_2">Пробел в селекторе определяет отношение предок/потомок. Скажем, мы хотим, чтобы ссылки в нашем заголовке были красного цвета:</section><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">a</span> {
    <span class="hljs-attribute">color</span>: red;
}</code></pre><section id="h2-20_4"></section><section id="h2-20_5">Это можно читать справа налево как: «выбрать все элементы <code id="h2-20_6">&lt;a&gt;</code>, которые находятся внутри элемента <code id="h2-20_7">&lt;header&gt;</code>. Это заставит все другие ссылки (которые не в заголовке) оставаться неизменными.</section><section id="h2-20_8"><img id="h2-20_9" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/warning.png" height="20"> Чем длиннее ряд селекторов, тем дольше обрабатывается CSS-свойства.</section></div></div>
<h1 id="triangularflagonpost6"><section id="triangularflagonpost6_0"><img id="triangularflagonpost6_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 6. Наследование</section></h1>
<div><section id="triangularflagonpost6_2"></section><section id="triangularflagonpost6_3"><b id="triangularflagonpost6_4">Наследование в CSS</b> — это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами), но только в том случае, если они где-то явно не переопределены.</section><section id="triangularflagonpost6_5">Если мы пропишем следующий код в таблицу стилей:</section><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#913D88</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;
}</code></pre><section id="triangularflagonpost6_7"></section><section id="triangularflagonpost6_8">, то можем заметить, что текст на странице принял свойства,которые мы прописали для тега <code id="triangularflagonpost6_9">&lt;body&gt;</code> (и цвет, и размер шрифта). А вот рамка <b id="triangularflagonpost6_10">border</b> появляется только один раз – для тега <code id="triangularflagonpost6_11">&lt;body&gt;</code>, но не для его дочерних элементов.</section><section id="triangularflagonpost6_12">Почему рамка не появилась у других элементов веб-страницы? Всё потому, что согласно спецификации CSS, существуют определенные правила наследования. Есть свойства, которые наследуются (в основном, это свойства, определяющие внешний вид текста) и те, которые <b id="triangularflagonpost6_13">не</b> наследуются (например, <b id="triangularflagonpost6_14">border</b>, а также свойства, определяющие границы, поля, отступы). К тому же, у браузеров есть свои стили, установленные по умолчанию. Именно поэтому стандартная синяя подчеркнутая гиперссылка <b id="triangularflagonpost6_15">a</b> не будет перенимать от <b id="triangularflagonpost6_16">body</b> свойство <b id="triangularflagonpost6_17">color</b>, что видно на скриншоте.</section><section id="triangularflagonpost6_18">Спецификацией CSS предусмотрено наследование свойств, относящихся к текстовому содержимому страницы, таких как <code id="triangularflagonpost6_19">color</code>, <code id="triangularflagonpost6_20">font</code>, <code id="triangularflagonpost6_21">letter-spacing</code>, <code id="triangularflagonpost6_22">line-height</code>, <code id="triangularflagonpost6_23">list-style</code>, <code id="triangularflagonpost6_24">text-align</code>, <code id="triangularflagonpost6_25">text-indent</code>, <code id="triangularflagonpost6_26">text-transform</code>, <code id="triangularflagonpost6_27">visibility</code>, <code id="triangularflagonpost6_28">white-space</code> и <code id="triangularflagonpost6_29">word-spacing</code>. 
Во многих случаях это удобно, так как не нужно задавать размер шрифта и семейство шрифтов для каждого элемента веб-страницы.</section><section id="triangularflagonpost6_30"><b id="triangularflagonpost6_31"><i id="triangularflagonpost6_32">Свойства, относящиеся к форматированию блоков, не наследуются</i></b>. Это <code id="triangularflagonpost6_33">background</code>, <code id="triangularflagonpost6_34">border</code>, <code id="triangularflagonpost6_35">display</code>, <code id="triangularflagonpost6_36">float</code> и <code id="triangularflagonpost6_37">clear</code>, <code id="triangularflagonpost6_38">height</code> и <code id="triangularflagonpost6_39">width</code>, <code id="triangularflagonpost6_40">margin</code>, <code id="triangularflagonpost6_41">min-max-height</code> и <code id="triangularflagonpost6_42">-width</code>, <code id="triangularflagonpost6_43">outline</code>, <code id="triangularflagonpost6_44">overflow</code>, <code id="triangularflagonpost6_45">padding</code>,<code id="triangularflagonpost6_46">position</code>, <code id="triangularflagonpost6_47">text-decoration</code>, <code id="triangularflagonpost6_48">vertical-align</code> и <code id="triangularflagonpost6_49">z-index</code>.</section><section id="triangularflagonpost6_50">С помощью ключевого слова <b id="triangularflagonpost6_51">inherit</b> можно принудить элемент наследовать любое значение свойства родительского элемента. Это работает даже для тех свойств, которые не наследуются по умолчанию. Например:
</section><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#913D88</span>;
	<span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;
}

<span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">border</span>: inherit;
}</code></pre><section id="triangularflagonpost6_53"></section><section id="triangularflagonpost6_54">Такой вариант удобен тем, что при необходимости можно внести правки только в стиль для элемента <code id="triangularflagonpost6_55">body</code>, а на теги <code id="triangularflagonpost6_56">&lt;p&gt;</code> тратить время не нужно, так как стиль автоматически изменится и для них.</section></div>
<h1 id="triangularflagonpost7"><section id="triangularflagonpost7_0"><img id="triangularflagonpost7_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 7. Псевдоклассы</section></h1>
<div><section id="triangularflagonpost7_2"></section><section id="triangularflagonpost7_3"><b id="triangularflagonpost7_4">Псевдокласс</b> в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Например, <b id="triangularflagonpost7_5"><i id="triangularflagonpost7_6">:hover</i></b> может быть использован для изменения цвета кнопки при наведении курсора на неё.
</section><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#F89B4D</span>;
}
</code></pre><section id="triangularflagonpost7_8">
</section><ul id="triangularflagonpost7_9"><li id="triangularflagonpost7_10"><section id="triangularflagonpost7_11">  <b id="triangularflagonpost7_12">:link</b> — не посещенная ссылка;</section></li><li id="triangularflagonpost7_13"><section id="triangularflagonpost7_14">  <b id="triangularflagonpost7_15">:visited</b> — посещенная ссылка;</section></li><li id="triangularflagonpost7_16"><section id="triangularflagonpost7_17">  <b id="triangularflagonpost7_18">:hover</b> — любой элемент, по которому проводят курсором мыши;</section></li><li id="triangularflagonpost7_19"><section id="triangularflagonpost7_20">  <b id="triangularflagonpost7_21">:focus</b> — интерактивный элемент, к которому перешли с помощью клавиатуры или активировали посредством мыши;</section></li><li id="triangularflagonpost7_22"><section id="triangularflagonpost7_23">  <b id="triangularflagonpost7_24">:disabled</b> — заблокированные поля форм, т.е., находящиеся в неактивном состоянии;</section></li><li id="triangularflagonpost7_25"><section id="triangularflagonpost7_26">  <b id="triangularflagonpost7_27">:not(селектор)</b> — элементы, которые не содержат указанный селектор — класс, идентификатор, название или тип поля формы — :not([type="submit"]);</section></li><li id="triangularflagonpost7_28"><section id="triangularflagonpost7_29">  <b id="triangularflagonpost7_30">:checked</b> — выделенные (выбранные пользователем) элементы формы.</section></li></ul><section id="triangularflagonpost7_31">
Псевдоклассы дают возможность стилизовать элемент на основе не только отношений в DOM-дереве, но и основываясь на внешних факторах, таких как история посещений (например, <code id="triangularflagonpost7_32">:visited</code>), состояние содержимого (вроде <code id="triangularflagonpost7_33">:checked</code> у некоторых элементов формы) или позиции курсора мыши (например, <code id="triangularflagonpost7_34">:hover</code> определяет, находится ли курсор мыши над элементом)</section><section id="triangularflagonpost7_35">Например: давайте запишем состояние ссылки при разных результатах действия пользователя (!!! стили обязательно размещайте их в следующей последовательности):
</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> { <span class="hljs-attribute">color</span>: red; }  <span class="hljs-comment">/* обычный цвет ссылки */</span>
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> { <span class="hljs-attribute">color</span>: grey; }  <span class="hljs-comment">/* цвет ссылки, которую пользователь уже посещал */</span>
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> { <span class="hljs-attribute">color</span>: blue; }  <span class="hljs-comment">/* цвет ссылки, на которую наведен курсор */</span>
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> { <span class="hljs-attribute">background-color</span>: yellow; }  <span class="hljs-comment">/* цвет фона ссылки в момент нажатия на нее */</span>
</code></pre></div>
<h1 id="triangularflagonpost8"><section id="triangularflagonpost8_0"><img id="triangularflagonpost8_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 8. Структурные псевдоклассы</section></h1>
<div><section id="triangularflagonpost8_2"></section><section id="triangularflagonpost8_3">В CSS3 существует ряд псевдоклассов для работы с дочерними элементами. Ниже приведено описание каждого из них, примеры использования, а также отличия между псевдоклассами вида «child» и «of-type».
</section><ul id="triangularflagonpost8_4"><li id="triangularflagonpost8_5"><section id="triangularflagonpost8_6">  <b id="triangularflagonpost8_7"> :nth-child(odd)</b> — нечётные дочерние элементы;</section></li><li id="triangularflagonpost8_8"><section id="triangularflagonpost8_9">  <b id="triangularflagonpost8_10">:nth-child(even)</b> — чётные дочерние элементы;</section></li><li id="triangularflagonpost8_11"><section id="triangularflagonpost8_12">  <b id="triangularflagonpost8_13">:nth-child(3n)</b> — каждый третий элемент среди дочерних;</section></li><li id="triangularflagonpost8_14"><section id="triangularflagonpost8_15">  <b id="triangularflagonpost8_16">:nth-child(n+2)</b> — выбирает все элементы, начиная со второго;</section></li><li id="triangularflagonpost8_17"><section id="triangularflagonpost8_18">  <b id="triangularflagonpost8_19">:nth-child(-n+2)</b> - первые 2</section></li><li id="triangularflagonpost8_20"><section id="triangularflagonpost8_21">  <b id="triangularflagonpost8_22">:nth-child(3)</b> — выбирает третий дочерний элемент;</section></li><li id="triangularflagonpost8_23"><section id="triangularflagonpost8_24">  <b id="triangularflagonpost8_25">:first-child</b> — позволяет оформить только самый первый дочерний элемент тега;</section></li><li id="triangularflagonpost8_26"><section id="triangularflagonpost8_27">  <b id="triangularflagonpost8_28">:last-child</b> — позволяет форматировать последний дочерний элемент тега;</section></li><li id="triangularflagonpost8_29"><section id="triangularflagonpost8_30">  <b id="triangularflagonpost8_31">:only-child</b> — выбирает элемент, являющийся единственным дочерним элементом;</section></li><li id="triangularflagonpost8_32"><section id="triangularflagonpost8_33">  <b id="triangularflagonpost8_34">:empty</b> — выбирает элементы, у которых нет дочерних элементов;</section><section id="triangularflagonpost8_35">Почитать можно и <a href="https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048" id="triangularflagonpost8_36">тут</a></section><section id="triangularflagonpost8_37">Потренироваться в использовании можно <a href="https://css-tricks.com/examples/nth-child-tester/" id="triangularflagonpost8_38">тут</a> </section></li></ul></div>
<h1 id="triangularflagonpost9"><section id="triangularflagonpost9_0"><img id="triangularflagonpost9_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 9. Структурные псевдоэлементы</section></h1>
<div><section id="triangularflagonpost9_2"></section><section id="triangularflagonpost9_3">Если псевдоклассы записываются с одним двоеточием, то псевдоэлементы – с двумя. Это было внедрено в CSS3 для того, чтобы различать псевдоклассы и псевдоэлементы между собой. Однако раньше этой разницы не существовало и с псевдоэлементами использовалось одно двоеточие. Сейчас браузеры поддерживают оба варианта написания (но не для всех случаев). Рассмотрим некоторые псевдоэлементы:
</section><ul id="triangularflagonpost9_4"><li id="triangularflagonpost9_5"><section id="triangularflagonpost9_6">  <b id="triangularflagonpost9_7">::after</b> – используется вместе со свойством <b id="triangularflagonpost9_9">content</b> и позволяет вывести необходимые данные после содержимого элемента;</section></li><li id="triangularflagonpost9_10"><section id="triangularflagonpost9_11">  <b id="triangularflagonpost9_12">::before</b> – выполняет похожую функцию, что и предыдущий, только выводит данные <i id="triangularflagonpost9_14">перед</i> содержимым элемента;</section></li><li id="triangularflagonpost9_15"><section id="triangularflagonpost9_16">  <b id="triangularflagonpost9_17">::selection</b> – этот псевдоэлемент распознается браузерами только при использовании двух двоеточий и позволяет установить цвет и фон для текста, который выделен пользователем;</section></li><li id="triangularflagonpost9_19"><section id="triangularflagonpost9_20">  <b id="triangularflagonpost9_21">::first-letter</b> – используется для изменения стиля первого символа в тексте элемента;</section></li><li id="triangularflagonpost9_23"><section id="triangularflagonpost9_24">  <b id="triangularflagonpost9_25">::first-line</b> – используется для изменения стиля первой строки текста элемента.</section></li></ul><section id="triangularflagonpost9_27">
Например:
</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span> 
    <span class="hljs-params">&lt;p&gt;</span>При выделении этого текста он изменит свой цвет.<span class="hljs-params">&lt;/p&gt;</span>
<span class="hljs-symbol">
CSS:</span>
<span class="hljs-symbol">    p:</span>:<span class="hljs-class">selection </span>{
<span class="hljs-symbol">        color:</span> <span class="hljs-meta">#ff0; <span class="hljs-comment">/* Цвет текста */</span></span>
<span class="hljs-symbol">        background:</span> <span class="hljs-meta">#000; <span class="hljs-comment">/* Цвет фона */</span></span>
    }
<span class="hljs-symbol">    
    p:</span>:first-<span class="hljs-class">letter </span>{
        font-family: <span class="hljs-string">"Times New Roman"</span>, Times, serif; <span class="hljs-comment">/* Гарнитура шрифта первой буквы */</span>
        font-size: <span class="hljs-number">20</span>px; <span class="hljs-comment">/* Размер шрифта первого символа */</span>
<span class="hljs-symbol">        color:</span> red; <span class="hljs-comment">/* Красный цвет текста */</span>
    }</code></pre><hr id="triangularflagonpost9_29"><section id="triangularflagonpost9_30"></section><section id="triangularflagonpost9_31">Остановимся подробнее на <b id="triangularflagonpost9_32">::after</b> и  <b id="triangularflagonpost9_34">::before</b>.  Псэвдоелементы :before и :after предельно просто прописываются в css-коде. Вот простой пример использования:</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-id">#example</span><span class="hljs-selector-pseudo">::before</span> {
       <span class="hljs-attribute">content</span>: <span class="hljs-string">"#"</span>;
    }
    <span class="hljs-selector-id">#example</span><span class="hljs-selector-pseudo">::after</span> {
       <span class="hljs-attribute">content</span>: <span class="hljs-string">"."</span>;
    }</code></pre><section id="triangularflagonpost9_39">
<img id="triangularflagonpost9_40" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/heavy_exclamation_mark.png" height="20"> Здесь важно отметить две вещи:
</section><ul id="triangularflagonpost9_41"><li id="triangularflagonpost9_42"><section id="triangularflagonpost9_43">  <b id="triangularflagonpost9_44">Во первых</b>, мы указываем на реальный html элемент с помощью строк #example::before и #example::after. Приставки после двоеточия, означают, что это стиль не просто элемента, а его псевдоэлементов.</section></li><li id="triangularflagonpost9_48"><section id="triangularflagonpost9_49">  <b id="triangularflagonpost9_50">Во-вторых</b>, вы не сможете ничего добавить без свойства <b id="triangularflagonpost9_51">content</b>, которое указывает, что именно должно отображаться как псевдоэлемент.</section><section id="triangularflagonpost9_52">Вы можете оставить свойство <b id="triangularflagonpost9_53">content</b> пустым, и создать блок.</section></li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-id">#example</span><span class="hljs-selector-pseudo">:before</span> {
       <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
       <span class="hljs-attribute">display</span>: block;
       <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
       <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    }</code></pre><section id="triangularflagonpost9_55">
Если вы удалите свойство content, псевдоэлемент работать не будет. По крайней мере, это совойство должно оставаться пустым. </section><section id="triangularflagonpost9_56">Если прописать <code id="triangularflagonpost9_57">normal</code>, <code id="triangularflagonpost9_58">none</code> — содержимое псевдоэлемента не отображается. (полезно, если нужно скрыть ранее заданный псевдоэлемент)</section><section id="triangularflagonpost9_59">Контент, который вставляется невидим на html странице. Он видим только в CSS.</section><section id="triangularflagonpost9_60">Также, вставляемый контент, по умолчанию будет строчным элементом. Чтобы сделать его блочным достаточно указать <b id="triangularflagonpost9_61">display:block;</b>, указать ширину и высоту блока. Это очень удобно при создании вкладок, кнопок и т.д.</section><section id="triangularflagonpost9_62">Важно заметить, что псевдоэлементы не наследуют стилей от родительских элементов (такие как внутренний и внешний отступы). Поэтому для каждого псевдоэлемента, необходимо указывать свои параметры стилей.</section><h2 id="afterbefore"><section id="afterbefore_0">Возможности псевдоэлеметов <code id="afterbefore_1">::after</code> и  <code id="afterbefore_2">::before</code></section></h2><div><section id="afterbefore_3"></section><section id="afterbefore_4">Что же мы можем вставить с помощью этих псевдоэлементов?</section><section id="afterbefore_5"><img id="afterbefore_6" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/rocket.png" height="20"> 1. <b id="afterbefore_7">Символы и текст</b>. Рассмотрим пример: давайте добавим кавычки в начало и конец текста тега  <b id="afterbefore_9">&lt;blockquote&gt;:</b></section><section id="afterbefore_10"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-401.jpg" alt="" id="afterbefore_11">
</section><pre><code class="hljs awk">CSS:
    blockquote::before {
    	content: <span class="hljs-string">""";
    }
    
    blockquote::after {
        	content: """</span>;
    }
    
    blockquote::selection {
    	color: <span class="hljs-comment">#c8f7c5;</span>
    	background-color: <span class="hljs-comment">#f9f0de;</span>
    }</code></pre><section id="afterbefore_13"></section><section id="afterbefore_14">Мы написали стиль для  длинных цитат, который добавляет кавычки в начале и в конце содержимого тега <b id="afterbefore_15">&lt;blockquote&gt;</b>, а также изменяет цвет и фон выделенного пользователем текста цитаты.</section><section id="afterbefore_16">Можем вместо кавычек вставить <a href="http://yoksel.github.io/unicode-table/" id="afterbefore_17">символы юникода</a>:</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">blockquote</span><span class="hljs-selector-pseudo">::before</span> {
    	<span class="hljs-attribute">content</span>: <span class="hljs-string">"\2728"</span>;
    }
</code></pre><section id="afterbefore_19"></section><section id="afterbefore_20">или текст:</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">blockquote</span><span class="hljs-selector-pseudo">::before</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">"Цитата:"</span>;
        <span class="hljs-attribute">color</span>: red;
    }
</code></pre><section id="afterbefore_22">
<img id="afterbefore_23" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/rocket.png" height="20"> 2. <b id="afterbefore_24">Изображения в качестве фона</b>. Давайте перед каждым пунктом списка сделаем вместо “точек”, например, цветочки: </section><section id="afterbefore_25"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-404.jpg" alt="" id="afterbefore_26"></section><pre><code class="hljs maxima">HTML:
    &lt;ul&gt;
      &lt;<span class="hljs-built_in">li</span>&gt;Item <span class="hljs-number">1</span>&lt;/<span class="hljs-built_in">li</span>&gt;
      &lt;<span class="hljs-built_in">li</span>&gt;Item <span class="hljs-number">2</span>&lt;/<span class="hljs-built_in">li</span>&gt;
      &lt;<span class="hljs-built_in">li</span>&gt;Item <span class="hljs-number">3</span>&lt;/<span class="hljs-built_in">li</span>&gt;
      &lt;<span class="hljs-built_in">li</span>&gt;Item <span class="hljs-number">4</span>&lt;/<span class="hljs-built_in">li</span>&gt;
      &lt;<span class="hljs-built_in">li</span>&gt;Item <span class="hljs-number">5</span>&lt;/<span class="hljs-built_in">li</span>&gt;
    &lt;/ul&gt;

CSS:
    <span class="hljs-built_in">li</span> {
      list-<span class="hljs-built_in">style</span>: none;
    }
    
    <span class="hljs-built_in">li</span>:before {
        <span class="hljs-built_in">background</span>-<span class="hljs-built_in">image</span>: url('http://<span class="hljs-built_in">image</span>.flaticon.com/icons/png/<span class="hljs-number">512</span>/<span class="hljs-number">253</span>/<span class="hljs-number">253551.</span>png');
        <span class="hljs-built_in">background</span>-size: 20px 20px;
        <span class="hljs-built_in">background</span>-repeat: no-repeat;
        <span class="hljs-built_in">background</span>-<span class="hljs-built_in">position</span>: <span class="hljs-number">50</span><span class="hljs-symbol">%</span> <span class="hljs-number">50</span><span class="hljs-symbol">%</span>;
        <span class="hljs-built_in">display</span>: inline-<span class="hljs-built_in">block</span>;
        <span class="hljs-built_in">width</span>: 25px; 
        <span class="hljs-built_in">height</span>: 20px;
        <span class="hljs-built_in">content</span>:<span class="hljs-string">""</span>;
    }</code></pre><section id="afterbefore_28"></section><section id="afterbefore_29"><img id="afterbefore_30" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/rocket.png" height="20"> 3. <b id="afterbefore_31">Картинку</b>. Для этого в свойстве <i id="afterbefore_32">content</i> вы можете прописать URL картинки( как это делается в background). Важно помнить, что нельзя URL брать в кавычки, это будет значить что контент является текстом.
</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>
    <span class="hljs-params">&lt;p&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Perspiciatis, odit?<span class="hljs-params">&lt;/p&gt;</span>
<span class="hljs-symbol">
CSS:</span>
<span class="hljs-symbol">    p:</span><span class="hljs-class">before </span>{
<span class="hljs-symbol">      content:</span> url(https:<span class="hljs-comment">//i.gifer.com/PUM3.gif);</span>
    }
</code></pre><section id="afterbefore_34"></section><section id="afterbefore_35"><img id="afterbefore_36" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/rocket.png" height="20"> 4. <b id="afterbefore_37">Cчетчик</b> - <code id="afterbefore_38">&lt;counter&gt;</code>. С помощью этого значения можно пронумеровать не только списки, но и любые элементы на странице. Например, разделы статьи.
</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">body</span> {
        <span class="hljs-attribute">counter-reset</span>: h2-counter;
        <span class="hljs-attribute">counter-reset</span>: p-counter;
    }
    <span class="hljs-selector-tag">div</span>{
        <span class="hljs-attribute">counter-increment</span>: h2-counter;
    }
    
    <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:before</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h2-counter) <span class="hljs-string">". "</span>;
    }
    
    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:before</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(p-counter) <span class="hljs-string">". "</span>;
        <span class="hljs-attribute">counter-increment</span>: p-counter;
    }
</code></pre><section id="afterbefore_40"></section><section id="afterbefore_41"><img id="afterbefore_42" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/rocket.png" height="20"> 5. <b id="afterbefore_43">Содержимое заданного атрибута</b> - <code id="afterbefore_44">attr(&lt;identifier&gt;</code>). Удобно использовать для вывода атрибутов <code id="afterbefore_45">href</code> в версии для печати и для разных интересных эффектов.</section><pre><code class="hljs yaml"><span class="hljs-attr">HTML:</span>
    <span class="hljs-string">&lt;p&gt;I'm</span> <span class="hljs-string">text.</span> <span class="hljs-string">&lt;a</span> <span class="hljs-string">href="#"</span> <span class="hljs-string">title="I'm</span> <span class="hljs-string">link"&gt;I'm</span> <span class="hljs-string">link&lt;/a&gt;&lt;/p&gt;</span>

<span class="hljs-attr">CSS:</span>
    <span class="hljs-string">a</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">position:</span> <span class="hljs-string">relative;</span>
    <span class="hljs-string">}</span>
    
    <span class="hljs-string">a:before</span> <span class="hljs-string">{</span>
        <span class="hljs-attr">content:</span> <span class="hljs-string">attr(title);</span>
        <span class="hljs-attr">position:</span> <span class="hljs-string">absolute;</span>
        <span class="hljs-attr">z-index:</span> <span class="hljs-number">10</span><span class="hljs-string">;</span>
        <span class="hljs-attr">right:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
        <span class="hljs-attr">top:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
        <span class="hljs-attr">left:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
        <span class="hljs-attr">height:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
        <span class="hljs-attr">overflow:</span> <span class="hljs-string">hidden;</span>
        <span class="hljs-attr">background:</span> <span class="hljs-string">red;</span>
        <span class="hljs-attr">color:</span> <span class="hljs-comment">#FFF;</span>
        <span class="hljs-attr">transition:</span> <span class="hljs-string">all</span> <span class="hljs-string">.3s;</span>
    <span class="hljs-string">}</span>
    
    <span class="hljs-string">a:hover:before</span> <span class="hljs-string">{</span>
        <span class="hljs-attr">height:</span> <span class="hljs-number">100</span><span class="hljs-string">%;</span>
    <span class="hljs-string">}</span></code></pre><section id="afterbefore_47"></section><section id="afterbefore_48">Мы видим, что возможности использования псевдоэлементов достаточно обширны. Нужно лишь знать где их и как применить))</section></div></div>
<h1 id="triangularflagonpost10css"><section id="triangularflagonpost10css_0"><img id="triangularflagonpost10css_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 10. Единицы измерения в CSS</section></h1>
<div><section id="triangularflagonpost10css_2"></section><section id="triangularflagonpost10css_3"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-402.jpg" alt="" id="triangularflagonpost10css_4" style="width: 400px;"></section><section id="triangularflagonpost10css_5">Существует много свойств CSS, которые требуют <b id="triangularflagonpost10css_6">размер в качестве единицы</b>:
</section><ul id="triangularflagonpost10css_7"><li id="triangularflagonpost10css_8"><section id="triangularflagonpost10css_9">  <b id="triangularflagonpost10css_10"><i id="triangularflagonpost10css_11">font-size</i></b> определяет размер текста;</section></li><li id="triangularflagonpost10css_12"><section id="triangularflagonpost10css_13">  <b id="triangularflagonpost10css_14"><i id="triangularflagonpost10css_15">border-width</i></b> определяет толщину границ элементов;</section></li><li id="triangularflagonpost10css_16"><section id="triangularflagonpost10css_17">  <b id="triangularflagonpost10css_18"><i id="triangularflagonpost10css_19">margin</i></b> определяет пространство между элементами;</section></li><li id="triangularflagonpost10css_20"><section id="triangularflagonpost10css_21">  <b id="triangularflagonpost10css_22"><i id="triangularflagonpost10css_23">left/right/top/bottom</i></b> позволяют позиционировать и перемещать элементы.</section><hr id="triangularflagonpost10css_24"><section id="triangularflagonpost10css_25"></section><section id="triangularflagonpost10css_26"><img id="triangularflagonpost10css_27" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/pushpin.png" height="20"> <b id="triangularflagonpost10css_28">Наиболее часто используемые единицы</b>:
</section></li><li id="triangularflagonpost10css_29"><section id="triangularflagonpost10css_30">  px для пикселей;</section></li><li id="triangularflagonpost10css_31"><section id="triangularflagonpost10css_32">  % для процентов;</section></li><li id="triangularflagonpost10css_33"><section id="triangularflagonpost10css_34">  em для определения размера относительно родительского значения font-size.</section></li></ul><h2 id="px"><section id="px_0">Пиксели <code id="px_1">(px)</code></section></h2><div><section id="px_2">
Поскольку компьютерные экраны используют пиксели для отображения содержимого, это <b id="px_3">самая распространённая единица размера в CSS</b>.</section><section id="px_4">Пиксель может быть использован для задания фиксированной <b id="px_5">ширины</b> элемента:
</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>; }</code></pre><section id="px_7">
Или установить <b id="px_8">размер текста</b>:</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>; }</code></pre><section id="px_10">
Пиксели в CSS являются простыми, поскольку они определяют <b id="px_11">абсолютные значения</b> и не зависят от других наследуемых свойств CSS.</section><section id="px_12">Они также широко используются для <b id="px_13">позиционирования</b> и <b id="px_14">расстояния</b>.</section></div><h2 id="h2-28"><section id="h2-28_0">Проценты <code id="h2-28_1">(%)</code></section></h2><div><section id="h2-28_2"></section><section id="h2-28_3">Проценты — это <b id="h2-28_4">относительные единицы</b>: они полагаются на родителя и/или предка элемента.</section><section id="h2-28_5">К примеру, блочные элементы, такие как абзацы, естественным образом занимают <b id="h2-28_6">всю доступную ширину</b>. Следующее правило CSS изменит их размер до <b id="h2-28_7">половины</b> доступной ширины.</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">p</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>; }</code></pre><section id="h2-28_9">
Проценты могут помочь задать другие свойства CSS, такие как размер текста.</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>
    <span class="hljs-params">&lt;p&gt;</span>Есть <span class="hljs-params">&lt;strong&gt;</span>важные<span class="hljs-params">&lt;/strong&gt;</span> проблемы, стоящие перед нами.<span class="hljs-params">&lt;/p&gt;</span>
<span class="hljs-symbol">
CSS:</span>
    <span class="hljs-class">strong </span>{ font-size: <span class="hljs-number">150</span>%; }
</code></pre></div><h2 id="em"><section id="em_0"><code id="em_1">em</code></section></h2><div><section id="em_2"></section><section id="em_3"><b id="em_4">em</b> является относительной единицей и <b id="em_5"><i id="em_6">зависит от значения font-size элемента</i></b>.</section><section id="em_7">Например, если у родителя font-size задан как 20px и вы применяете font-size: 0.8em к дочернему элементу, то этот дочерний элемент будет отображать font-size как 16px.</section><section id="em_8"><img id="em_9" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/heavy_exclamation_mark.png" height="20"> Не следует путать размер em с селектором em, который ориентирован на элемент <code id="em_10">&lt;em&gt;</code>.</section><section id="em_11">Единица em интересна для определения размера шрифта элементов HTML относительно друг друга. Для создания привлекательной и комфортной для чтения веб-страницы вам необходимо обеспечить визуальную глубину. Например, вы хотите, чтобы ваши <code id="em_12">&lt;h1&gt;</code> были вдвое больше, чем основной текст, ваши <code id="em_13">&lt;h2&gt;</code> в 1,5 раза больше, а боковая панель немного меньше. Это можно легко получить в CSS:
</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; }

    <span class="hljs-selector-tag">h1</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>; }        <span class="hljs-comment">/* = 32px */</span>

    <span class="hljs-selector-tag">h2</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span>; }      <span class="hljs-comment">/* = 24px */</span>

    <span class="hljs-selector-tag">aside</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.75em</span>; }  <span class="hljs-comment">/* = 12px */</span></code></pre><section id="em_15"></section><section id="em_16">Если вы решите изменить размер текста <code id="em_17">&lt;body&gt;</code>, относительные размеры заголовков и боковой панели <b id="em_18">изменятся соответственно</b> и ваша веб-страница останется <b id="em_19">визуально сбалансированной</b>.</section><section id="em_20">Только изменив одно значение, поменяются и все остальные значения:</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>; }
    
    <span class="hljs-selector-tag">h1</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>; }        <span class="hljs-comment">/* = 40px */</span>
    
    <span class="hljs-selector-tag">h2</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span>; }      <span class="hljs-comment">/* = 30px */</span>
    
    <span class="hljs-selector-tag">aside</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.75em</span>; }  <span class="hljs-comment">/* = 15px */</span></code></pre></div><h2 id="rem"><section id="rem_0"><code id="rem_1">rem</code></section></h2><div><section id="rem_2"></section><section id="rem_3">Единица <b id="rem_4">rem</b> похожа на em, но вместо зависимости от родительского значения, она <b id="rem_5">опирается на значение корневого элемента</b>, которым является элемент <code id="rem_6">&lt;html&gt;</code>.</section><pre><code class="hljs css"><span class="hljs-selector-tag">CSS</span>:
    <span class="hljs-selector-tag">html</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>; }
    
    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>; }     <span class="hljs-comment">/* = 18px */</span>
    
    <span class="hljs-selector-tag">h1</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>; }       <span class="hljs-comment">/* = 36px */</span>
    
    <span class="hljs-selector-tag">h2</span> { <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>; }     <span class="hljs-comment">/* = 27px */</span></code></pre><section id="rem_8">
<img id="rem_9" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/point_up.png" height="20"> Разница между rem и em в том, что значение rem фиксировано, в то время как значения em умножаются друг с другом.
</section><pre><code class="hljs angelscript">Если вы установили html { font-size: <span class="hljs-number">18</span>px; }:

*   <span class="hljs-number">2</span>rem всегда будет равно <span class="hljs-number">36</span>px, независимо от того, где оно используется в вашем CSS;
*   <span class="hljs-number">2</span>em всегда будет равно удвоенному font-size родителя, что не обязательно равно <span class="hljs-number">36</span>px.</code></pre><section id="rem_11">
Быстрый пример, где 2em отличается от 2rem:</section><pre><code class="hljs dts"><span class="hljs-symbol">HTML:</span>
    <span class="hljs-params">&lt;p&gt;</span>Есть <span class="hljs-params">&lt;strong&gt;</span>важные<span class="hljs-params">&lt;/strong&gt;</span> проблемы, <span class="hljs-params">&lt;span&gt;</span>стоящие<span class="hljs-params">&lt;/span&gt;</span> перед нами.<span class="hljs-params">&lt;/p&gt;</span>
<span class="hljs-symbol">
CSS:</span>
    <span class="hljs-class">html </span>{ font-size: <span class="hljs-number">20</span>px; }
    
    <span class="hljs-class">p </span>{ font-size: <span class="hljs-number">0.8</span>rem; }        <span class="hljs-comment">/* = 16px */</span>
    
    p <span class="hljs-class">span </span>{ font-size: <span class="hljs-number">2</span>em; }      <span class="hljs-comment">/* = 16px * 2 = 32px */</span>
    
    p <span class="hljs-class">strong </span>{ font-size: <span class="hljs-number">2</span>rem; }   <span class="hljs-comment">/* = 20px * 2 = 40px */</span></code></pre><section id="rem_13"></section><section id="rem_14"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-403.jpg" alt="" id="rem_15"></section><section id="rem_16">
<code id="rem_17">&lt;span&gt;</code> полагается на значение font-size у <code id="rem_18">&lt;р&gt;</code>, в то время как <code id="rem_19">&lt;strong&gt;</code> полагается на значение font-size у <code id="rem_20">&lt;html&gt;</code>.</section><section id="rem_21">Если  размер в em/rem изменить, задав его больше единицы,  то шрифт увеличится. Если его задать меньше единицы, то шрифт уменьшится. Т.е. цифра рядом с единицей em является множителем для размера шрифта.</section></div><h2 id="h2-31"><section id="h2-31_0">Какую единицу использовать?</section></h2><div><section id="h2-31_1"></section><section id="h2-31_2">Наверное, лучше всего все-таки начать с <b id="h2-31_3">пикселей</b>: поскольку это абсолютная величина, они не зависят от контекста элемента. Пиксели простые, позволяют установить размер текста, ширину и высоту изображения, толщину границы, координаты положения и др.</section><section id="h2-31_4"><b id="h2-31_5">Проценты</b> и значения <b id="h2-31_6">em</b> могут быть использованы наряду с пикселями, особенно для относительных размеров текста.
</section><table><thead><tr><th><section id="h2-31_7">Единица измерения</section></th><th><section id="h2-31_8">Описание</section></th><th><section id="h2-31_9">Пример использования единицы измерени</section></th></tr></thead><tbody><tr><td><section id="h2-31_10">%</section></td><td><section id="h2-31_11">Устанавливает измерение в процентах относительно другого значения, как правило, охватывающего элемента.</section></td><td><section id="h2-31_12">div {width: 50%;}</section></td></tr><tr><td><section id="h2-31_13">em</section></td><td><section id="h2-31_14">Относительное измерение высоты шрифта в em пространстве. Поскольку единица em эквивалентна размеру данного шрифта, то, если Вы укажите шрифт 12pх, каждый элемент «em» будет 12pх. Таким образом, 2em будет 24pх.</section></td><td><section id="h2-31_15">h1 {letter-spacing: 3em;}</section></td></tr><tr><td><section id="h2-31_16">px</section></td><td><section id="h2-31_17">Устанавливает измерение в пикселях экрана.</section></td><td><section id="h2-31_18">p {margin: 30px;}</section></td></tr><tr><td><section id="h2-31_19">vh</section></td><td><section id="h2-31_20">Равен 1% высоты окна просмотра.</section></td><td><section id="h2-31_21">h1 {font-size: 2.1vh;}</section></td></tr><tr><td><section id="h2-31_22">vw</section></td><td><section id="h2-31_23">Равен 1% ширины окна просмотра.</section></td><td><section id="h2-31_24">h2 {font-size: 2.2vw;}</section></td></tr><tr><td><section id="h2-31_25">vmin/vmax</section></td><td><section id="h2-31_26">Равен 1vw или 1vh, в зависимости от того, что меньше.</section></td><td><section id="h2-31_27">div {font-size: 5vmin;}</section></td></tr></tbody></table></div></div>
<h1 id="triangularflagonpost11css"><section id="triangularflagonpost11css_0"><img id="triangularflagonpost11css_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 11. Комментарии в CSS</section></h1>
<div><section id="triangularflagonpost11css_2"></section><section id="triangularflagonpost11css_3">Комментарии используются для добавления поясняющих заметок или для того, чтобы предотвратить интеграцию части кода в браузер.</section><section id="triangularflagonpost11css_4">Синтаксис коментирования CSS следующий:
</section><pre><code class="hljs actionscript"><span class="hljs-comment">/* Однострочный комментарий */</span> 


<span class="hljs-comment">/* Комментарий 
который содержит 
несколько строк */</span></code></pre></div>
<h1 id="triangularflagonpost12background"><section id="triangularflagonpost12background_0"><img id="triangularflagonpost12background_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 12. <code id="triangularflagonpost12background_2">background</code>. Фон.</section></h1>
<div><section id="triangularflagonpost12background_3"></section><section id="triangularflagonpost12background_4">Фон на веб-странице — это очень важно, поэтому для него предусмотрено немало свойств. Все они начинаются словом «Background». В переводе с английского «Background» и означает «Фон». О правилах оформления фона через CSS и пойдёт речь в статье.</section><h2 id="backgroundcolor"><section id="backgroundcolor_0"><code id="backgroundcolor_1">background-color</code></section></h2><div><section id="backgroundcolor_2"></section><section id="backgroundcolor_3">Мы уже говорили о свойстве <b id="backgroundcolor_4">color</b>, которое позволяет задать цвет переднего плана элемента, то есть букв текста. <b id="backgroundcolor_5">background-color</b> устанавливает задний фон любого HTML-элемента: таблицы, абзаца, списка и т. д.</section><section id="backgroundcolor_6">Например, цвет фона всей страницы можно настроить так:</section><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#EEFFCB</span>; }</code></pre></div><h2 id="backgroundimage"><section id="backgroundimage_0"><code id="backgroundimage_1">background-image</code></section></h2><div><section id="backgroundimage_2"></section><section id="backgroundimage_3">Устанавливает в качестве фона картинку. Если изображение подобрано правильно, то страница на его фоне будет выглядеть гораздо красивее, чем на фоне одноцветном.</section><section id="backgroundimage_4">Например, картинка background.png хранится в той же папке, что и веб-страница, и вы хотите установить её как фон параграфам этого HTML-документа. Код будет таким:</section><pre><code class="hljs css">    <span class="hljs-selector-tag">p</span> { <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(background.png); }</code></pre><section id="backgroundimage_6">
Для одного и того же веб-элемента можно установить несколько фоновых рисунков. Для этого достаточно перечислить их все в свойстве <b id="backgroundimage_7">background-image</b> через запятую:</section><pre><code class="hljs css">    <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(”image/background01.png”), <span class="hljs-built_in">url</span>(”image/background02.png”), <span class="hljs-built_in">url</span>(”image/background03.png”), <span class="hljs-built_in">url</span>(”image/background04.png”); }</code></pre><section id="backgroundimage_9">
Очевидно, что без определённого позиционирования выбранные рисунки при отображении будут накладываться друг на друга, причём первое из перечисленных будет самым верхним, последнее — под всеми, задним фоном.</section></div><h2 id="backgroundrepeat"><section id="backgroundrepeat_0"><code id="backgroundrepeat_1">background-repeat</code></section></h2><div><section id="backgroundrepeat_2"></section><section id="backgroundrepeat_3">По умолчанию фоновое изображение, если его размер меньше размера элемента, будет заполнять объект полностью, повторяясь с левого верхнего к правому нижнему углу.</section><section id="backgroundrepeat_4"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-bgi.png" alt="" id="backgroundrepeat_5" style="width: 400px;"></section><section id="backgroundrepeat_6">Бывают ситуации, когда такое заполнение неприемлемо. Как раз для них и существует свойство <b id="backgroundrepeat_7">background-repeat</b>, которому можно указать следующие значения:</section><table><thead><tr><th><section id="backgroundrepeat_8">property</section></th><th><section id="backgroundrepeat_9">comment</section></th></tr></thead><tbody><tr><td><section id="backgroundrepeat_10"><b id="backgroundrepeat_11">repeat</b></section></td><td><section id="backgroundrepeat_12">Задано по умолчанию. Результат вы видели на рисунке выше.</section></td></tr><tr><td><section id="backgroundrepeat_13"><b id="backgroundrepeat_14">repeat-x</b></section></td><td><section id="backgroundrepeat_15">Картинка будет повторяться только слева направо, по горизонтали. По вертикали не будет, так что заполнит только первый слой.</section></td></tr><tr><td><section id="backgroundrepeat_16"><b id="backgroundrepeat_17">repeat-y</b></section></td><td><section id="backgroundrepeat_18">Рисунок будет повторяться по вертикали, но не по горизонтали, то есть идти вдоль левой границы страницы.</section></td></tr><tr><td><section id="backgroundrepeat_19"><b id="backgroundrepeat_20">no-repeat</b></section></td><td><section id="backgroundrepeat_21">Фон не будет повторяться вообще.</section></td></tr></tbody></table><section id="backgroundrepeat_22"></section><section id="backgroundrepeat_23"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-bgr.png" alt="" id="backgroundrepeat_24" style="width: 500px; float: left;">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-bgry.png" alt="" id="backgroundrepeat_25" style="width: 500px;">
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-bgrnr.png" alt="" id="backgroundrepeat_26" style="width: 400px;"></section></div><h2 id="backgroundposition"><section id="backgroundposition_0"><code id="backgroundposition_1">background-position</code></section></h2><div><section id="backgroundposition_2"></section><section id="backgroundposition_3">Позволяет задать позицию фоновому изображению, ведь не всегда нужно, чтобы оно отображалось с левого верхнего угла окна браузера. Для позиционирования достаточно указать два значения через пробел: координату по оси X (горизонтальное позиционирование) и координату по оси Y (позиционирование вертикальное). Задавать их можно в любых единицах длины, но для абсолютных значений рекомендуется использовать пиксели (<b id="backgroundposition_4">px</b>), а для относительных — проценты (<b id="backgroundposition_5">%</b>).</section><pre><code class="hljs angelscript">    background-position: <span class="hljs-number">200</span>px <span class="hljs-number">350</span>px;</code></pre><section id="backgroundposition_7"></section><section id="backgroundposition_8">Также картинку можно позиционировать зарезервированными словами.
</section><table><thead><tr><th><section id="backgroundposition_9">property</section></th><th><section id="backgroundposition_10">comment</section></th></tr></thead><tbody><tr><td><section id="backgroundposition_11"><b id="backgroundposition_12">left</b>, <b id="backgroundposition_13">center</b> и <b id="backgroundposition_14">right</b></section></td><td><section id="backgroundposition_15">Для горизонтального расположения используются слова  (по левому краю, по центру и по правому краю соответственно)</section></td></tr><tr><td><section id="backgroundposition_16"> <b id="backgroundposition_17">top</b>, <b id="backgroundposition_18">center</b> и <b id="backgroundposition_19">bottom</b></section></td><td><section id="backgroundposition_20">позиционирование сверху, по центру и снизу..</section></td></tr></tbody></table></div><h2 id="backgroundattachment"><section id="backgroundattachment_0"><code id="backgroundattachment_1">background-attachment</code></section></h2><div><section id="backgroundattachment_2"></section><section id="backgroundattachment_3">Определяет, будет ли фоновая картинка прокручиваться вместе с содержимым страницы или будет оставаться неподвижной. Значения могут быть такими:
</section><table><thead><tr><th><section id="backgroundattachment_4">property</section></th><th><section id="backgroundattachment_5">comment</section></th></tr></thead><tbody><tr><td><section id="backgroundattachment_6"><b id="backgroundattachment_7">fixed</b></section></td><td><section id="backgroundattachment_8">фон зафиксирован</section></td></tr><tr><td><section id="backgroundattachment_9"><b id="backgroundattachment_10">scroll</b></section></td><td><section id="backgroundattachment_11">фон разблокирован (прокручивается)</section></td></tr><tr><td><section id="backgroundattachment_12"><b id="backgroundattachment_13">local</b></section></td><td><section id="backgroundattachment_14">рисунок прокручивается только с содержимым элемента, но дальше, если элемент уже закончился, не идёт.</section></td></tr></tbody></table><section id="backgroundattachment_15">
<b id="backgroundattachment_16"><i id="backgroundattachment_17">Если изображений несколько</i></b>, для них можно указать правила, перечислив их в одном свойстве background-attachment через запятую:</section><pre><code class="hljs gauss">    background-attachment: fixed, <span class="hljs-keyword">scroll</span>, <span class="hljs-keyword">local</span>;</code></pre></div><h2 id="backgroundclip"><section id="backgroundclip_0"><code id="backgroundclip_1">background-clip</code></section></h2><div><section id="backgroundclip_2"></section><section id="backgroundclip_3">Определяет, как фоновое изображение или цвет фона будут выводиться относительно границ элемента.
<img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-bgclip.png" alt="" id="backgroundclip_4" style="width: 800px;"></section><table><thead><tr><th><section id="backgroundclip_5">property</section></th><th><section id="backgroundclip_6">comment</section></th></tr></thead><tbody><tr><td><section id="backgroundclip_7"><b id="backgroundclip_8">content-box</b></section></td><td><section id="backgroundclip_9">фон отображается только под содержимым.</section></td></tr><tr><td><section id="backgroundclip_10"><b id="backgroundclip_11">border-box</b></section></td><td><section id="backgroundclip_12">выводится и под контентом, и под границами</section></td></tr><tr><td><section id="backgroundclip_13"><b id="backgroundclip_14">padding-box</b></section></td><td><section id="backgroundclip_15">отображается внутри границ.</section></td></tr></tbody></table></div><h2 id="backgroundorigin"><section id="backgroundorigin_0"><code id="backgroundorigin_1">background-origin</code></section></h2><div><section id="backgroundorigin_2"></section><section id="backgroundorigin_3">То же, что и <b id="backgroundorigin_4">background-clip</b>, с такими же значениями, только задаёт положение относительно границ не текущего элемента, а элемента-родителя.</section></div><h2 id="backgroundsize"><section id="backgroundsize_0"><code id="backgroundsize_1">background-size</code></section></h2><div><section id="backgroundsize_2"></section><section id="backgroundsize_3">Свойство указывает браузеру размеры фонового изображения. Вы можете задать их в любых единицах длины (через пробел указывается сначала ширина, потом высота картинки). Если прописано только одно значение, то оно определит ширину, высота при этом останется исходной, то есть такой, как в файле изображения. Чтобы указать только высоту, а ширину оставить оригинальной, свойству <b id="backgroundsize_4">background-size</b> нужно задать значения auto размер (например, background-size: auto 300px).</section><section id="backgroundsize_5">В правиле можно использовать ещё два значения.
</section><table><thead><tr><th><section id="backgroundsize_6">property</section></th><th><section id="backgroundsize_7">comment</section></th></tr></thead><tbody><tr><td><section id="backgroundsize_8"><b id="backgroundsize_9">cover</b></section></td><td><section id="backgroundsize_10">Масштабирует фон по размерам блока с сохранением исходных пропорций картинки, то есть рисунок не растянется и не станет слишком узким.</section></td></tr><tr><td><section id="backgroundsize_11"><b id="backgroundsize_12">contain</b></section></td><td><section id="backgroundsize_13">Помещает изображение внутрь блока, сохраняет пропорции.</section></td></tr></tbody></table></div><h2 id="background"><section id="background_0"><code id="background_1">background</code></section></h2><div><section id="background_2"></section><section id="background_3">Позволяет объединить значения перечисленных свойств в одной строке:</section><pre><code class="hljs maxima">    <span class="hljs-built_in">background</span>: url(<span class="hljs-string">"background.jpg"</span>) <span class="hljs-built_in">center</span> <span class="hljs-built_in">center</span> / 100px 100px no-repeat <span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>;</code></pre><section id="background_5"></section><section id="background_6">В примере между свойствами <b id="background_7">background-position</b> и <b id="background_8">background-size</b> стоит слеш (<b id="background_9">/</b>), которым их значения друг от друга необходимо отделять, дабы не запутывать браузер.</section></div></div>
<h1 id="triangularflagonpost13opacity"><section id="triangularflagonpost13opacity_0"><img id="triangularflagonpost13opacity_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 13. Прозрачность -  <code id="triangularflagonpost13opacity_2">opacity</code> </section></h1>
<div><section id="triangularflagonpost13opacity_3"></section><section id="triangularflagonpost13opacity_4">Определяет уровень прозрачности элемента веб-страницы. При частичной или полной прозрачности через элемент проступает фоновый рисунок или другие элементы, расположенные ниже полупрозрачного объекта</section><section id="triangularflagonpost13opacity_5"><b id="triangularflagonpost13opacity_6"><i id="triangularflagonpost13opacity_7">Значение по умолчанию</i></b>: 1</section><section id="triangularflagonpost13opacity_8"><b id="triangularflagonpost13opacity_9"><i id="triangularflagonpost13opacity_10">Синтаксис:</i></b></section><pre><code class="hljs dts"><span class="hljs-symbol">    opacity:</span> <span class="hljs-params">&lt;число&gt;</span></code></pre><section id="triangularflagonpost13opacity_12"></section><section id="triangularflagonpost13opacity_13">В качестве значения выступает число из диапазона [0.0; 1.0]. Значение 0 соответствует полной прозрачности элемента, 1, наоборот — его непрозрачности. Дробные числа вида 0.6 устанавливают полупрозрачность. Допускается писать числа без нуля впереди, вида opacity: .6.</section></div>
<h1 id="triangularflagonpost14"><section id="triangularflagonpost14_0"><img id="triangularflagonpost14_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 14. Текст. Стили для форматирования текста.</section></h1>
<div><section id="triangularflagonpost14_2"></section><section id="triangularflagonpost14_3">Свойства CSS для форматирования текста позволяют оформить содержимое страницы, не затрагивая HTML-код. В этом уроке узнаем, какие же параметры можно задать тексту через таблицу стилей</section><h2 id="texttransform"><section id="texttransform_0"><code id="texttransform_1">text-transform</code></section></h2><div><section id="texttransform_2"></section><section id="texttransform_3">Свойство <b id="texttransform_4"><i id="texttransform_5">text-transform</i></b> стилизует текст. Оно не влияет на базовое содержимое и не должно влиять на содержимое операции копирования и вставки простого текста.</section><section id="texttransform_6">Свойство наследуется.
</section><table><thead><tr><th><section id="texttransform_7">property</section></th><th><section id="texttransform_8">comment</section></th></tr></thead><tbody><tr><td><section id="texttransform_9"><b id="texttransform_10">none</b></section></td><td><section id="texttransform_11">Значение по умолчанию, означает отсутствие эффектов.</section></td></tr><tr><td><section id="texttransform_12"><b id="texttransform_13">capitalize</b></section></td><td><section id="texttransform_14">Изменяет написание первой буквы каждого слова в элементе, делая её прописной.</section></td></tr><tr><td><section id="texttransform_15"><b id="texttransform_16">uppercase</b></section></td><td><section id="texttransform_17"> Выводит все слова в элементе прописными буквами.</section></td></tr><tr><td><section id="texttransform_18"><b id="texttransform_19">lowercase</b></section></td><td><section id="texttransform_20">Выводит все слова в элементе строчными буквами.</section></td></tr><tr><td><section id="texttransform_21"><b id="texttransform_22">initial</b></section></td><td><section id="texttransform_23">Устанавливает значение свойства в значение по умолчанию.</section></td></tr><tr><td><section id="texttransform_24"><b id="texttransform_25">inherit</b></section></td><td><section id="texttransform_26">Наследует значение свойства от родительского элемента.</section></td></tr></tbody></table><section id="texttransform_27"></section><section id="texttransform_28"><b id="texttransform_29">Синтаксис</b>
</section><pre><code class="hljs pgsql">    <span class="hljs-type">text</span>-<span class="hljs-keyword">transform</span>: <span class="hljs-keyword">none</span>/capitalize/uppercase/lowercase/<span class="hljs-keyword">inherit</span>/initial;</code></pre></div><h2 id="textindent"><section id="textindent_0"><code id="textindent_1">text-indent</code></section></h2><div><section id="textindent_2"></section><section id="textindent_3">Свойство <b id="textindent_4">text-indent</b> позволяет задать отступ(пустое место) первой строки текста. Например, так можно отформатировать абзацы, чтобы лучше визуально отделить их друг от друга. В качестве значения используется цифра, задающая длину в процентах, единицах или пикселях. Отрицательное число превратит отступ в выступ.</section><section id="textindent_5"><b id="textindent_6">Синтаксис:</b> </section><pre><code class="hljs angelscript">    text-indent: <span class="hljs-number">20</span>px/<span class="hljs-number">15</span>%/inherit</code></pre></div><h2 id="whitespace"><section id="whitespace_0"><code id="whitespace_1">white-space</code></section></h2><div><section id="whitespace_2"></section><section id="whitespace_3">Свойство white-space обрабатывает пробелы между словами и переносы строк внутри элемента. Свойство наследуется.
</section><table><thead><tr><th><section id="whitespace_4">property</section></th><th><section id="whitespace_5">comment</section></th></tr></thead><tbody><tr><td><section id="whitespace_6"><b id="whitespace_7">normal</b></section></td><td><section id="whitespace_8">Значение по умолчанию. Между словами вставляется только по одному пробелу, дополнительные пробелы отбрасываются. Текст переносится только в случае необходимости.</section></td></tr><tr><td><section id="whitespace_9"><b id="whitespace_10">nowrap</b></section></td><td><section id="whitespace_11">Запрещает переносы строк, за исключением применения <code id="whitespace_12">&lt;br&gt;</code>.</section></td></tr><tr><td><section id="whitespace_13"><b id="whitespace_14">pre</b></section></td><td><section id="whitespace_15">Пробелы в тексте не игнорируются, браузер отображает дополнительные пробелы и переносы строк.</section></td></tr><tr><td><section id="whitespace_16"><b id="whitespace_17">pre-wrap</b></section></td><td><section id="whitespace_18">Сохраняет пробелы в тексте, делая разрывы строк там, где это необходимо.</section></td></tr><tr><td><section id="whitespace_19"><b id="whitespace_20">pre-line</b></section></td><td><section id="whitespace_21">Удаляет лишние пробелы, за исключением случаев <code id="whitespace_22">&lt;br&gt;</code>.</section></td></tr><tr><td><section id="whitespace_23"><b id="whitespace_24">break-spaces</b></section></td><td><section id="whitespace_25">Поведение идентично pre-wrap, за исключением того, что: любая последовательность неудаляемых пробелов всегда занимает место, в том числе в конце строки; возможность переноса строки существует после каждого неудаляемого пробела, в том числе между пробелами.</section></td></tr><tr><td><section id="whitespace_26"><b id="whitespace_27">initial</b></section></td><td><section id="whitespace_28">Устанавливает значение свойства в значение по умолчанию..</section></td></tr><tr><td><section id="whitespace_29"><b id="whitespace_30">inherit</b></section></td><td><section id="whitespace_31">Наследует значение свойства от родительского элемента.</section></td></tr></tbody></table><section id="whitespace_32"></section><section id="whitespace_33"><b id="whitespace_34">Синтаксис</b></section><pre><code class="hljs groovy">    white-<span class="hljs-string">space:</span> normal<span class="hljs-regexp">/nowrap/</span>pre<span class="hljs-regexp">/pre-wrap/</span>pre-line<span class="hljs-regexp">/break-spaces/</span>inherit/initial;</code></pre></div><h2 id="wordbreak"><section id="wordbreak_0"><code id="wordbreak_1">word-break</code></section></h2><div><section id="wordbreak_2"></section><section id="wordbreak_3">Свойство <b id="wordbreak_4"><i id="wordbreak_5">word-break</i></b> указывает, как делать перенос строк внутри слов, которые не помещаются по ширине в заданную область. Свойство наследуется.
</section><table><thead><tr><th><section id="wordbreak_6">property</section></th><th><section id="wordbreak_7">comment</section></th></tr></thead><tbody><tr><td><section id="wordbreak_8"><b id="wordbreak_9">normal</b></section></td><td><section id="wordbreak_10">Разрыв допускается в пределах слов. Перенос слов не применяется.</section></td></tr><tr><td><section id="wordbreak_11"><b id="wordbreak_12">break-all</b></section></td><td><section id="wordbreak_13">Разрыв допускается в пределах слов. Перенос слов не применяется.</section></td></tr><tr><td><section id="wordbreak_14"><b id="wordbreak_15">keep-all</b></section></td><td><section id="wordbreak_16">Запрещает разрывы между парами символов.</section></td></tr><tr><td><section id="wordbreak_17"><b id="wordbreak_18">initial</b></section></td><td><section id="wordbreak_19">Устанавливает значение свойства в значение по умолчанию.</section></td></tr><tr><td><section id="wordbreak_20"><b id="wordbreak_21">inherit</b></section></td><td><section id="wordbreak_22">Наследует значение свойства от родительского элемента.</section></td></tr></tbody></table><section id="wordbreak_23">
<b id="wordbreak_24">Синтаксис</b>
</section><pre><code class="hljs glsl">    word-<span class="hljs-keyword">break</span>: normal/<span class="hljs-keyword">break</span>-<span class="hljs-built_in">all</span>/keep-<span class="hljs-built_in">all</span>/inherit/initial;</code></pre></div><h2 id="wordwrap"><section id="wordwrap_0"><code id="wordwrap_1">word-wrap</code></section></h2><div><section id="wordwrap_2"></section><section id="wordwrap_3">Свойство <b id="wordwrap_4"><i id="wordwrap_5">word-wrap</i></b> указывает, переносить или нет длинные слова, которые не помещаются по ширине в заданную область. Свойство наследуется.</section><section id="wordwrap_6"><b id="wordwrap_7">Синтаксис</b>
</section><pre><code class="hljs livecodeserver">    <span class="hljs-built_in">word</span>-<span class="hljs-keyword">wrap</span>: <span class="hljs-keyword">normal</span> | break-<span class="hljs-built_in">word</span></code></pre><section id="wordwrap_9">
</section><table><thead><tr><th><section id="wordwrap_10">property</section></th><th><section id="wordwrap_11">comment</section></th></tr></thead><tbody><tr><td><section id="wordwrap_12"><b id="wordwrap_13">normal</b></section></td><td><section id="wordwrap_14">Строки не переносятся или переносятся в тех местах, где явно задан перенос (например, с помощью <code id="wordwrap_15">&lt;br&gt;</code>).</section></td></tr><tr><td><section id="wordwrap_16"><b id="wordwrap_17">break-word</b></section></td><td><section id="wordwrap_18">Перенос строк добавляется автоматически, чтобы слово поместилось в заданную ширину блока.</section></td></tr></tbody></table><section id="wordwrap_19">
Пример:
</section><pre><code class="hljs arduino">HTML:

    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">col</span>"&gt;
       &lt;p&gt;<span class="hljs-title">C</span>уществительное&lt;/p&gt;
       &lt;p&gt;высокопревосходительство&lt;/p&gt;
       &lt;p&gt;Одушевленное существительное&lt;/p&gt;
       &lt;p&gt;одиннадцатиклассница&lt;/p&gt;
       &lt;p&gt;Химическое вещество&lt;/p&gt;
       &lt;p&gt;метоксихлордиэтиламинометилбутиламиноакридин&lt;/p&gt;
      &lt;/div&gt;

<span class="hljs-title">CSS</span>:</span>
    .col { 
        <span class="hljs-built_in">background</span>: #f0f0f0; <span class="hljs-comment">/* Цвет фона */</span>
        <span class="hljs-built_in">width</span>: <span class="hljs-number">230</span>px; <span class="hljs-comment">/* Ширина блока */</span>
        padding: <span class="hljs-number">10</span>px; <span class="hljs-comment">/* Поля */</span>
        font-<span class="hljs-built_in">size</span>: <span class="hljs-number">1.5</span>em; <span class="hljs-comment">/* Размер шрифта */</span>
        <span class="hljs-keyword">word</span>-wrap: <span class="hljs-keyword">break</span>-<span class="hljs-keyword">word</span>; <span class="hljs-comment">/* Перенос слов */</span> 
    }</code></pre></div><h2 id="wordspacingletterspacing"><section id="wordspacingletterspacing_0"> <code id="wordspacingletterspacing_1">word-spacing</code> , <code id="wordspacingletterspacing_2">letter-spacing</code></section></h2><div><section id="wordspacingletterspacing_3"></section><section id="wordspacingletterspacing_4">CSS позволяет контролировать промежутки между словами и типографскими символами с помощью свойств word-spacing и letter-spacing.</section><section id="wordspacingletterspacing_5">Свойство <b id="wordspacingletterspacing_6"><i id="wordspacingletterspacing_7">word-spacing</i></b> определяет интервалы между словами. Можно использовать положительные и отрицательные значения. Свойство наследуется.</section><section id="wordspacingletterspacing_8">Свойство <b id="wordspacingletterspacing_9"><i id="wordspacingletterspacing_10">letter-spacing</i></b> определяет межбуквенный интервал. Свойство наследуется.</section><section id="wordspacingletterspacing_11"><b id="wordspacingletterspacing_12">Синтаксис: </b></section><pre><code class="hljs angelscript">    word-spacing: normal/<span class="hljs-number">1</span>px/<span class="hljs-number">0.2</span>e/<span class="hljs-number">50</span>%/inherit/initial;</code></pre><section id="wordspacingletterspacing_14">
</section><table><thead><tr><th><section id="wordspacingletterspacing_15">property</section></th><th><section id="wordspacingletterspacing_16">comment</section></th></tr></thead><tbody><tr><td><section id="wordspacingletterspacing_17"><b id="wordspacingletterspacing_18">normal</b></section></td><td><section id="wordspacingletterspacing_19">Дополнительный интервал не применяется. Вычисляет в 0. Значение по умолчанию.</section></td></tr><tr><td><section id="wordspacingletterspacing_20"><b id="wordspacingletterspacing_21">размер</b></section></td><td><section id="wordspacingletterspacing_22">Задает дополнительный интервал в дополнение к внутреннему интервалу между словами, определенному шрифтом. Значения могут быть отрицательными, но могут быть ограничения, зависящие от реализации.</section></td></tr><tr><td><section id="wordspacingletterspacing_23"><b id="wordspacingletterspacing_24">initial</b></section></td><td><section id="wordspacingletterspacing_25">Устанавливает значение свойства в значение по умолчанию.</section></td></tr><tr><td><section id="wordspacingletterspacing_26"><b id="wordspacingletterspacing_27">inherit</b></section></td><td><section id="wordspacingletterspacing_28">Наследует значение свойства от родительского элемента.</section></td></tr></tbody></table></div></div>
<h1 id="triangularflagonpost15font"><section id="triangularflagonpost15font_0"><img id="triangularflagonpost15font_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 15. <code id="triangularflagonpost15font_2">Font</code>. Стили для шрифта</section></h1>
<div><section id="triangularflagonpost15font_3"></section><section id="triangularflagonpost15font_4">В файле CSS вы можете настроить несколько свойств шрифта: <b id="triangularflagonpost15font_5">font-family, font-size, font-style</b>. Это наиболее часто используемые свойства шрифта.</section><h2 id="fontfamily"><section id="fontfamily_0"><code id="fontfamily_1">font-family</code></section></h2><div><section id="fontfamily_2"></section><section id="fontfamily_3">Свойство <b id="fontfamily_4"><i id="fontfamily_5">font-family</i></b> задает шрифт для элемента.</section><section id="fontfamily_6">Может содержать несколько "запасных" названий шрифтов. В случае если первый из списка не установлен на компьютере пользователя, используется второй.</section><section id="fontfamily_7">Существует два типа названия шрифтов:</section><section id="fontfamily_8">1)  <b id="fontfamily_9">family-name</b> - название семьи шрифтов. Например, "times", "courier", "arial"...
2)   <b id="fontfamily_10">generic-family</b> - универсальные семейства шрифтов, такое как "serif", "sans-serif", "cursive", "fantasy", "monospace".</section><section id="fontfamily_11"><b id="fontfamily_12">Универсальные семейства шрифтов:</b></section><ul id="fontfamily_13"><li id="fontfamily_14"><section id="fontfamily_15"><b id="fontfamily_16"><i id="fontfamily_17">serif</i></b> — шрифты с засечками (антиквенные), типа Times; </section></li><li id="fontfamily_18"><section id="fontfamily_19"><b id="fontfamily_20"><i id="fontfamily_21">sans-serif</i></b> — рубленные шрифты (шрифты без засечек или гротески), типичный представитель — Arial;</section></li><li id="fontfamily_22"><section id="fontfamily_23"><b id="fontfamily_24"><i id="fontfamily_25">cursive</i></b> — курсивные шрифты; </section></li><li id="fontfamily_26"><section id="fontfamily_27"><b id="fontfamily_28"><i id="fontfamily_29">fantasy</i></b> — декоративные шрифты; </section></li><li id="fontfamily_30"><section id="fontfamily_31"><b id="fontfamily_32"><i id="fontfamily_33">monospace</i></b> — моноширинные шрифты, ширина каждого символа в таком семействе одинакова.</section><section id="fontfamily_34"><img id="fontfamily_35" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/exclamation.png" height="20"> Начните с нужного шрифта и всегда заканчивайте названием семейства, чтобы браузер мог выбрать аналогичный шрифт в семействе, если другие шрифты недоступны.</section><section id="fontfamily_36"><img id="fontfamily_37" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/point_right.png" height="20"> <b id="fontfamily_38">Примечание</b>. Разделяйте каждое значение запятой. Если имя шрифта содержит пробел, оно должно быть заключено в кавычки. </section></li></ul><section id="fontfamily_39">
<b id="fontfamily_40">Синтаксис:</b></section><pre><code class="hljs 1c">    font-family: &lt;<span class="hljs-type">шрифт</span>&gt; [, &lt;<span class="hljs-type">шрифт</span>&gt;[, ...]]</code></pre><section id="fontfamily_42"></section><section id="fontfamily_43"><b id="fontfamily_44">Значения:</b> Любое количество имен шрифтов разделенных запятыми. 
</section><ul id="fontfamily_45"><li id="fontfamily_46"><section id="fontfamily_47">  serif — шрифты с засечками (антиквенные), типа Times;</section></li><li id="fontfamily_48"><section id="fontfamily_49">  sans-serif — рубленные шрифты (шрифты без засечек или гротески), типичный представитель Arial;</section></li><li id="fontfamily_50"><section id="fontfamily_51">  cursive — курсивные шрифты;</section></li><li id="fontfamily_52"><section id="fontfamily_53">  fantasy — декоративные шрифты;</section></li><li id="fontfamily_54"><section id="fontfamily_55">  monospace — моноширинные шрифты, ширина каждого символа в таком семействе одинакова (шрифт Courier).</section></li></ul></div><h2 id="fontweight"><section id="fontweight_0"><code id="fontweight_1">font-weight</code></section></h2><div><section id="fontweight_2"></section><section id="fontweight_3">Устанавливает насыщенность шрифта. </section><section id="fontweight_4">
<b id="fontweight_5">Синтаксис</b></section><pre><code class="hljs coq">    font-weight: bold|<span class="hljs-type">bolder</span>|<span class="hljs-type">lighter</span>|<span class="hljs-type">normal</span>|<span class="hljs-type">100</span>|<span class="hljs-type">200</span>|<span class="hljs-type">300</span>|<span class="hljs-type">400</span>|<span class="hljs-type">500</span>|<span class="hljs-type">600</span>|<span class="hljs-type">700</span>|<span class="hljs-type">800</span>|<span class="hljs-type">900</span></code></pre><section id="fontweight_7"></section><section id="fontweight_8"><b id="fontweight_9">Значения</b></section><section id="fontweight_10">Насыщенность шрифта задаётся с помощью ключевых слов: bold — жирное начертание и normal — нормальное начертание. Также допустимо использовать условные единицы от 100 до 900. Значения bolder и lighter изменяют жирность относительно насыщенности родителя, соответственно, в большую и меньшую сторону.</section><section id="fontweight_11">Вот как числовые значения влияют на насыщенность шрифта.
</section><ul id="fontweight_12"><li id="fontweight_13"><section id="fontweight_14">  100 — тонкое начертание;</section></li><li id="fontweight_15"><section id="fontweight_16">  200 — сверхсветлое;</section></li><li id="fontweight_17"><section id="fontweight_18">  300 — светлое;</section></li><li id="fontweight_19"><section id="fontweight_20">  400 — нормальное (аналогично normal);</section></li><li id="fontweight_21"><section id="fontweight_22">  500 — среднее;</section></li><li id="fontweight_23"><section id="fontweight_24">  600 — полужирное;</section></li><li id="fontweight_25"><section id="fontweight_26">  700 — жирное (аналогично bold);</section></li><li id="fontweight_27"><section id="fontweight_28">  800 — сверхжирное;</section></li><li id="fontweight_29"><section id="fontweight_30">  900 — тяжёлое.</section><section id="fontweight_31">Учтите, что не все шрифты поддерживают этот набор. Если указанное значение не поддерживается, то браузер приведёт шрифт к ближайшей насыщенности. К примеру, если вы указали 900 и оно не может быть показано, то браузер в действительности применит значение 700 как ближайшее, которое работает корректно.</section></li></ul></div><h2 id="fontstyle"><section id="fontstyle_0"><code id="fontstyle_1">font-style</code></section></h2><div><section id="fontstyle_2"></section><section id="fontstyle_3">Определяет начертание шрифта — <b id="fontstyle_4"><i id="fontstyle_5">обычное</i></b>, <b id="fontstyle_6"><i id="fontstyle_7">курсивное</i></b> или <b id="fontstyle_8"><i id="fontstyle_9">наклонное</i></b>. Когда для текста установлено курсивное или наклонное начертание, браузер обращается к системе для поиска подходящего шрифта. Если заданный шрифт не найден, браузер использует специальный алгоритм для имитации нужного вида текста.
</section><table><thead><tr><th><section id="fontstyle_10">property</section></th><th><section id="fontstyle_11">comment</section></th></tr></thead><tbody><tr><td><section id="fontstyle_12"><b id="fontstyle_13">italic</b></section></td><td><section id="fontstyle_14">Курсивный шрифт</section></td></tr><tr><td><section id="fontstyle_15"><b id="fontstyle_16">oblique</b></section></td><td><section id="fontstyle_17">Наклонный шрифт (все символы с обычным начертанием просто наклоняются вправо)</section></td></tr><tr><td><section id="fontstyle_18"><b id="fontstyle_19">normal</b></section></td><td><section id="fontstyle_20">Обычный шрифт</section></td></tr><tr><td><section id="fontstyle_21"><b id="fontstyle_22">inherit</b></section></td><td><section id="fontstyle_23">Наследует значение родител</section></td></tr></tbody></table><section id="fontstyle_24"></section><section id="fontstyle_25"><b id="fontstyle_26">Синтаксис</b></section><pre><code class="hljs css">    <span class="hljs-selector-tag">p</span> {
        <span class="hljs-attribute">font-style</span>: italic;
    }</code></pre></div><h2 id="fontsize"><section id="fontsize_0"><code id="fontsize_1">font-size</code></section></h2><div><section id="fontsize_2"></section><section id="fontsize_3">Определяет размер шрифта элемента. Размер может быть установлен несколькими способами. 
</section><ol id="fontsize_4"><li id="fontsize_5"><section id="fontsize_6"><b id="fontsize_7"><i id="fontsize_8">В абсолютных размерах</i></b> - xx-small, x-small, small, medium, large, x-large, xx-large- зависит от настроек браузера и операционной системы:</section><pre><code class="hljs scss">    <span class="hljs-attribute">font-size</span>: xx-small; 
    <span class="hljs-attribute">font-size</span>: x-small;
    <span class="hljs-attribute">font-size</span>: small;
    <span class="hljs-attribute">font-size</span>: medium; 
    <span class="hljs-attribute">font-size</span>: large; 
    <span class="hljs-attribute">font-size</span>: x-large; 
    <span class="hljs-attribute">font-size</span>: xx-large;</code></pre><section id="fontsize_10">
    </section></li><li id="fontsize_11"><section id="fontsize_12"><b id="fontsize_13"><i id="fontsize_14">В относительных размерах</i></b> - larger, smaller - по отношению в размеру шрифта родительского элемента</section><pre><code class="hljs scss">    <span class="hljs-attribute">font-size</span>: larger; 
    <span class="hljs-attribute">font-size</span>: smaller;</code></pre><section id="fontsize_16">
</section></li><li id="fontsize_17"><section id="fontsize_18"><b id="fontsize_19"><i id="fontsize_20">В значениях длины:</i></b></section><pre><code class="hljs scss">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>; 
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>;</code></pre><section id="fontsize_22">
</section></li><li id="fontsize_23"><section id="fontsize_24"><b id="fontsize_25"><i id="fontsize_26">Процентные значения:</i></b></section><pre><code class="hljs matlab">    font-<span class="hljs-built_in">size</span>: <span class="hljs-number">80</span><span class="hljs-comment">%;</span></code></pre><section id="fontsize_28">
</section></li><li id="fontsize_29"><section id="fontsize_30"><b id="fontsize_31"><i id="fontsize_32">Глобальные значения:</i></b></section><pre><code class="hljs scss">    <span class="hljs-attribute">font-size</span>: inherit; 
    <span class="hljs-attribute">font-size</span>: initial;</code></pre><section id="fontsize_34"></section><section id="fontsize_35"><img id="fontsize_36" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/exclamation.png" height="20"> &lt;значение длины&gt; или &lt;процентное значение&gt; расчитываются по отношению к размеру родительского элемента.</section></li></ol></div><h2 id="lineheight"><section id="lineheight_0"><code id="lineheight_1">line-height</code></section></h2><div><section id="lineheight_2"></section><section id="lineheight_3">Межстрочный интервал <b id="lineheight_4">line-height</b> задаётся свойством, в качестве значения которого может указываться:
</section><ul id="lineheight_5"><li id="lineheight_6"><section id="lineheight_7">  <b id="lineheight_8">Процент.</b> Высчитывается от размера шрифта элемента.</section></li><li id="lineheight_9"><section id="lineheight_10">  <b id="lineheight_11">Число.</b> Определяется как множитель от размера шрифта, который принимается за единицу. Например <b id="lineheight_12">line-height: 1.5;</b> установит полуторный интервал.</section></li><li id="lineheight_13"><section id="lineheight_14">  <b id="lineheight_15">Пиксели</b> или <b id="lineheight_16">пункты</b>. Определяют не переменное, как предыдущие варианты, а постоянное расстояние.</section><section id="lineheight_17">--- </section><section id="lineheight_18">Давайте рассмотрим на примере, что является размером шрифта и межстрочным интервалом:</section><section id="lineheight_19"><img src="https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-font.png" alt="" id="lineheight_20" style="width: 400px;"></section></li></ul></div></div>
<h1 id="triangularflagonpost16textaligncss"><section id="triangularflagonpost16textaligncss_0"><img id="triangularflagonpost16textaligncss_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20">  16. <code id="triangularflagonpost16textaligncss_2">text-align</code> - Выравнивание текста в CSS</section></h1>
<div><section id="triangularflagonpost16textaligncss_3"></section><section id="triangularflagonpost16textaligncss_4">В таких программах, как, например, Microsoft Word вы наверняка встречали инструменты выравнивания текста по горизонтали. Выровнять текст можно по левому или по правому краю, по центру или по ширине. То же самое есть и в CSS – выравнивание текста производится с помощью свойства <b id="triangularflagonpost16textaligncss_5">text-align</b> и соответствующих значений, которые показаны в таблице:
</section><table><thead><tr><th><section id="triangularflagonpost16textaligncss_6">property</section></th><th><section id="triangularflagonpost16textaligncss_7">comment</section></th></tr></thead><tbody><tr><td><section id="triangularflagonpost16textaligncss_8"><b id="triangularflagonpost16textaligncss_9">left</b></section></td><td><section id="triangularflagonpost16textaligncss_10">По левому краю</section></td></tr><tr><td><section id="triangularflagonpost16textaligncss_11"><b id="triangularflagonpost16textaligncss_12">right</b></section></td><td><section id="triangularflagonpost16textaligncss_13">По правому  краю</section></td></tr><tr><td><section id="triangularflagonpost16textaligncss_14"><b id="triangularflagonpost16textaligncss_15">center</b></section></td><td><section id="triangularflagonpost16textaligncss_16">По центру страницы/блока</section></td></tr><tr><td><section id="triangularflagonpost16textaligncss_17"><b id="triangularflagonpost16textaligncss_18">justify</b></section></td><td><section id="triangularflagonpost16textaligncss_19">По ширине страницы/блока</section></td></tr><tr><td><section id="triangularflagonpost16textaligncss_20"><b id="triangularflagonpost16textaligncss_21">start</b></section></td><td><section id="triangularflagonpost16textaligncss_22">Выравнивание текста по тому краю, с которого он начинается (то есть текст, идущий слева направо, выравнивается по левому краю)</section></td></tr><tr><td><section id="triangularflagonpost16textaligncss_23"><b id="triangularflagonpost16textaligncss_24">end</b></section></td><td><section id="triangularflagonpost16textaligncss_25">Выравнивание текста по противоположному краю (то есть текст, идущий слева направо, выравнивается по правому краю)</section></td></tr></tbody></table><section id="triangularflagonpost16textaligncss_26"></section><section id="triangularflagonpost16textaligncss_27">.</section><section id="triangularflagonpost16textaligncss_28"><b id="triangularflagonpost16textaligncss_29">Синтаксис:</b></section><pre><code class="hljs css">    <span class="hljs-selector-tag">p</span> {
        <span class="hljs-attribute">text-align</span>: left;
    }</code></pre><section id="triangularflagonpost16textaligncss_31">
<img id="triangularflagonpost16textaligncss_32" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/exclamation.png" height="20"> Значения <b id="triangularflagonpost16textaligncss_33">start</b> и <b id="triangularflagonpost16textaligncss_34">end</b> не поддерживаются некоторыми браузерами, включая Internet Explorer, поэтому, если нет острой необходимости в их применении, рекомендуем использовать значения <b id="triangularflagonpost16textaligncss_35">left</b> и <b id="triangularflagonpost16textaligncss_36">right</b>.</section></div>
<h1 id="triangularflagonpost17verticalalign"><section id="triangularflagonpost17verticalalign_0"><img id="triangularflagonpost17verticalalign_1" src="https://www.webfx.com/tools/emoji-cheat-sheet/graphics/emojis/triangular_flag_on_post.png" height="20"> 17. <code id="triangularflagonpost17verticalalign_2">vertical-align</code> - вертикальное выравнивание</section></h1>
<div><section id="triangularflagonpost17verticalalign_3"></section><section id="triangularflagonpost17verticalalign_4">Может задаваться только для строчных элементов (картинок, форм), определяется свойством <b id="triangularflagonpost17verticalalign_5">vertical-align</b>. С его помощью выравнивается не содержимое, а сами элементы, кроме случая с ячейкой – использование vertical-align выравнивает не её саму, а только расположенный в ней текст. Значения могут быть следующими:</section><table><thead><tr><th><section id="triangularflagonpost17verticalalign_6">property</section></th><th><section id="triangularflagonpost17verticalalign_7">comment</section></th></tr></thead><tbody><tr><td><section id="triangularflagonpost17verticalalign_8"><b id="triangularflagonpost17verticalalign_9">baseline</b></section></td><td><section id="triangularflagonpost17verticalalign_10">задаётся свойству по умолчанию и выравнивает базовую линию элемента по базовой линии родителя. Если у родителя её нет, то выравнивание происходит по нижней границе.</section></td></tr><tr><td><section id="triangularflagonpost17verticalalign_11"><b id="triangularflagonpost17verticalalign_12">top</b> и <b id="triangularflagonpost17verticalalign_13">bottom</b></section></td><td><section id="triangularflagonpost17verticalalign_14">Если задано первое значение, то верхний край элемента будет совпадать с верхним краем самого высокого элемента строки. Можно сказать, что <b id="triangularflagonpost17verticalalign_15">top</b> — это выравнивание по верхнему краю. Второе свойство выполняет противоположную функцию — совмещает нижний край оформляемого элемента с нижней частью элемента, расположенного в строке ниже всех, то есть происходит выравнивание по нижнему краю.</section></td></tr><tr><td><section id="triangularflagonpost17verticalalign_16"><b id="triangularflagonpost17verticalalign_17">text-top</b> и <b id="triangularflagonpost17verticalalign_18">text-bottom</b></section></td><td><section id="triangularflagonpost17verticalalign_19">От предыдущих свойств отличаются тем, что выравнивание происходит по самым нижним и верхним текстовым элементам, а не любым.</section></td></tr><tr><td><section id="triangularflagonpost17verticalalign_20"><b id="triangularflagonpost17verticalalign_21">sub</b> и <b id="triangularflagonpost17verticalalign_22">super</b></section></td><td><section id="triangularflagonpost17verticalalign_23">Аналоги HTML-тегов <b id="triangularflagonpost17verticalalign_24">&lt;sub&gt;</b> и <b id="triangularflagonpost17verticalalign_25">&lt;sup&gt;</b>. Первое свойство делает элемент подстрочным, второе — надстрочным. Шрифт текста при этом не меняется.</section></td></tr><tr><td><section id="triangularflagonpost17verticalalign_26"><b id="triangularflagonpost17verticalalign_27">middle</b></section></td><td><section id="triangularflagonpost17verticalalign_28">Выравнивание по центру относительно элемента-родителя.</section></td></tr></tbody></table><section id="triangularflagonpost17verticalalign_29"></section><section id="triangularflagonpost17verticalalign_30">Также с помощью <b id="triangularflagonpost17verticalalign_31">vertical-align</b> можно переместить элемент вверх или вниз, указав значение в пикселях, единицах или процентах. Положительная цифра переместит его вверх, отрицательная — вниз.</section></div>
    </div>
</body>
</html>